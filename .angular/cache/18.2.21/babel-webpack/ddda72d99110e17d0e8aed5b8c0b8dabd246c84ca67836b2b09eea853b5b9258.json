{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/alves/OneDrive/Documentos/MovimentosManuais/movimentos-manuais-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, inject, Injectable, ElementRef, Renderer2, makeEnvironmentProviders, input, output, signal, HostListener, Directive, Pipe } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nvar MaskExpression = /*#__PURE__*/function (MaskExpression) {\n  MaskExpression[\"SEPARATOR\"] = \"separator\";\n  MaskExpression[\"PERCENT\"] = \"percent\";\n  MaskExpression[\"IP\"] = \"IP\";\n  MaskExpression[\"CPF_CNPJ\"] = \"CPF_CNPJ\";\n  MaskExpression[\"MONTH\"] = \"M\";\n  MaskExpression[\"MONTHS\"] = \"M0\";\n  MaskExpression[\"MINUTE\"] = \"m\";\n  MaskExpression[\"HOUR\"] = \"h\";\n  MaskExpression[\"HOURS\"] = \"H\";\n  MaskExpression[\"MINUTES\"] = \"m0\";\n  MaskExpression[\"HOURS_HOUR\"] = \"Hh\";\n  MaskExpression[\"SECONDS\"] = \"s0\";\n  MaskExpression[\"HOURS_MINUTES_SECONDS\"] = \"Hh:m0:s0\";\n  MaskExpression[\"EMAIL_MASK\"] = \"A*@A*.A*\";\n  MaskExpression[\"HOURS_MINUTES\"] = \"Hh:m0\";\n  MaskExpression[\"MINUTES_SECONDS\"] = \"m0:s0\";\n  MaskExpression[\"DAYS_MONTHS_YEARS\"] = \"d0/M0/0000\";\n  MaskExpression[\"DAYS_MONTHS\"] = \"d0/M0\";\n  MaskExpression[\"DAYS\"] = \"d0\";\n  MaskExpression[\"DAY\"] = \"d\";\n  MaskExpression[\"SECOND\"] = \"s\";\n  MaskExpression[\"LETTER_S\"] = \"S\";\n  MaskExpression[\"DOT\"] = \".\";\n  MaskExpression[\"COMMA\"] = \",\";\n  MaskExpression[\"CURLY_BRACKETS_LEFT\"] = \"{\";\n  MaskExpression[\"CURLY_BRACKETS_RIGHT\"] = \"}\";\n  MaskExpression[\"MINUS\"] = \"-\";\n  MaskExpression[\"OR\"] = \"||\";\n  MaskExpression[\"HASH\"] = \"#\";\n  MaskExpression[\"EMPTY_STRING\"] = \"\";\n  MaskExpression[\"SYMBOL_STAR\"] = \"*\";\n  MaskExpression[\"SYMBOL_QUESTION\"] = \"?\";\n  MaskExpression[\"SLASH\"] = \"/\";\n  MaskExpression[\"WHITE_SPACE\"] = \" \";\n  MaskExpression[\"NUMBER_ZERO\"] = \"0\";\n  MaskExpression[\"NUMBER_NINE\"] = \"9\";\n  MaskExpression[\"BACKSPACE\"] = \"Backspace\";\n  MaskExpression[\"DELETE\"] = \"Delete\";\n  MaskExpression[\"ARROW_LEFT\"] = \"ArrowLeft\";\n  MaskExpression[\"ARROW_UP\"] = \"ArrowUp\";\n  MaskExpression[\"DOUBLE_ZERO\"] = \"00\";\n  return MaskExpression;\n}(MaskExpression || {});\nconst NGX_MASK_CONFIG = new InjectionToken('ngx-mask config');\nconst NEW_CONFIG = new InjectionToken('new ngx-mask config');\nconst INITIAL_CONFIG = new InjectionToken('initial ngx-mask config');\nconst initialConfig = {\n  suffix: '',\n  prefix: '',\n  thousandSeparator: ' ',\n  decimalMarker: ['.', ','],\n  clearIfNotMatch: false,\n  showMaskTyped: false,\n  instantPrefix: false,\n  placeHolderCharacter: '_',\n  dropSpecialCharacters: true,\n  hiddenInput: false,\n  shownMaskExpression: '',\n  separatorLimit: '',\n  allowNegativeNumbers: false,\n  validation: true,\n  specialCharacters: ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']', '\"', \"'\"],\n  leadZeroDateTime: false,\n  apm: false,\n  leadZero: false,\n  keepCharacterPositions: false,\n  triggerOnMaskChange: false,\n  inputTransformFn: value => value,\n  outputTransformFn: value => value,\n  maskFilled: new EventEmitter(),\n  patterns: {\n    '0': {\n      pattern: new RegExp('\\\\d')\n    },\n    '9': {\n      pattern: new RegExp('\\\\d'),\n      optional: true\n    },\n    X: {\n      pattern: new RegExp('\\\\d'),\n      symbol: '*'\n    },\n    A: {\n      pattern: new RegExp('[a-zA-Z0-9]')\n    },\n    S: {\n      pattern: new RegExp('[a-zA-Z]')\n    },\n    U: {\n      pattern: new RegExp('[A-Z]')\n    },\n    L: {\n      pattern: new RegExp('[a-z]')\n    },\n    d: {\n      pattern: new RegExp('\\\\d')\n    },\n    m: {\n      pattern: new RegExp('\\\\d')\n    },\n    M: {\n      pattern: new RegExp('\\\\d')\n    },\n    H: {\n      pattern: new RegExp('\\\\d')\n    },\n    h: {\n      pattern: new RegExp('\\\\d')\n    },\n    s: {\n      pattern: new RegExp('\\\\d')\n    }\n  }\n};\nconst timeMasks = [MaskExpression.HOURS_MINUTES_SECONDS, MaskExpression.HOURS_MINUTES, MaskExpression.MINUTES_SECONDS];\nconst withoutValidation = [MaskExpression.PERCENT, MaskExpression.HOURS_HOUR, MaskExpression.SECONDS, MaskExpression.MINUTES, MaskExpression.SEPARATOR, MaskExpression.DAYS_MONTHS_YEARS, MaskExpression.DAYS_MONTHS, MaskExpression.DAYS, MaskExpression.MONTHS];\nlet NgxMaskApplierService = /*#__PURE__*/(() => {\n  class NgxMaskApplierService {\n    _config = inject(NGX_MASK_CONFIG);\n    dropSpecialCharacters = this._config.dropSpecialCharacters;\n    hiddenInput = this._config.hiddenInput;\n    clearIfNotMatch = this._config.clearIfNotMatch;\n    specialCharacters = this._config.specialCharacters;\n    patterns = this._config.patterns;\n    prefix = this._config.prefix;\n    suffix = this._config.suffix;\n    thousandSeparator = this._config.thousandSeparator;\n    decimalMarker = this._config.decimalMarker;\n    customPattern;\n    showMaskTyped = this._config.showMaskTyped;\n    placeHolderCharacter = this._config.placeHolderCharacter;\n    validation = this._config.validation;\n    separatorLimit = this._config.separatorLimit;\n    allowNegativeNumbers = this._config.allowNegativeNumbers;\n    leadZeroDateTime = this._config.leadZeroDateTime;\n    leadZero = this._config.leadZero;\n    apm = this._config.apm;\n    inputTransformFn = this._config.inputTransformFn;\n    outputTransformFn = this._config.outputTransformFn;\n    keepCharacterPositions = this._config.keepCharacterPositions;\n    instantPrefix = this._config.instantPrefix;\n    triggerOnMaskChange = this._config.triggerOnMaskChange;\n    _shift = new Set();\n    plusOnePosition = false;\n    maskExpression = '';\n    actualValue = '';\n    showKeepCharacterExp = '';\n    shownMaskExpression = this._config.shownMaskExpression;\n    deletedSpecialCharacter = false;\n    ipError;\n    cpfCnpjError;\n    applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    cb = () => {}) {\n      if (!maskExpression || typeof inputValue !== 'string') {\n        return MaskExpression.EMPTY_STRING;\n      }\n      let cursor = 0;\n      let result = '';\n      let multi = false;\n      let backspaceShift = false;\n      let shift = 1;\n      let stepBack = false;\n      let processedValue = inputValue;\n      let processedPosition = position;\n      const startsWithPrefix = processedValue.slice(0, this.prefix.length) === this.prefix;\n      const pastedFullWithPrefix = justPasted && processedValue.length === this.prefix.length + maskExpression.length;\n      const looksLikeFullPrefixPaste = processedValue === this.prefix + processedValue.slice(this.prefix.length);\n      if (startsWithPrefix && (pastedFullWithPrefix || looksLikeFullPrefixPaste)) {\n        processedValue = processedValue.slice(this.prefix.length);\n      }\n      if (!!this.suffix && processedValue.length > 0) {\n        processedValue = this.checkAndRemoveSuffix(processedValue);\n      }\n      if (processedValue === '(' && this.prefix) {\n        processedValue = '';\n      }\n      const inputArray = processedValue.toString().split(MaskExpression.EMPTY_STRING);\n      if (this.allowNegativeNumbers && processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS) {\n        result += processedValue.slice(cursor, cursor + 1);\n      }\n      if (maskExpression === MaskExpression.IP) {\n        const valuesIP = processedValue.split(MaskExpression.DOT);\n        this.ipError = this._validIP(valuesIP);\n        // eslint-disable-next-line no-param-reassign\n        maskExpression = '099.099.099.099';\n      }\n      const arr = [];\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < processedValue.length; i++) {\n        if (processedValue[i]?.match('\\\\d')) {\n          arr.push(processedValue[i] ?? MaskExpression.EMPTY_STRING);\n        }\n      }\n      if (maskExpression === MaskExpression.CPF_CNPJ) {\n        this.cpfCnpjError = arr.length !== 11 && arr.length !== 14;\n        if (arr.length > 11) {\n          // eslint-disable-next-line no-param-reassign\n          maskExpression = '00.000.000/0000-00';\n        } else {\n          // eslint-disable-next-line no-param-reassign\n          maskExpression = '000.000.000-00';\n        }\n      }\n      if (maskExpression.startsWith(MaskExpression.PERCENT)) {\n        if (processedValue.match('[a-z]|[A-Z]') ||\n        // eslint-disable-next-line no-useless-escape\n        processedValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/.]/) && !backspaced) {\n          processedValue = this._stripToDecimal(processedValue);\n          const precision = this.getPrecision(maskExpression);\n          processedValue = this.checkInputPrecision(processedValue, precision, this.decimalMarker);\n        }\n        const decimalMarker = typeof this.decimalMarker === 'string' ? this.decimalMarker : MaskExpression.DOT;\n        if (processedValue.indexOf(decimalMarker) > 0 && !this.percentage(processedValue.substring(0, processedValue.indexOf(decimalMarker)))) {\n          let base = processedValue.substring(0, processedValue.indexOf(decimalMarker) - 1);\n          if (this.allowNegativeNumbers && processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS && !backspaced) {\n            base = processedValue.substring(0, processedValue.indexOf(decimalMarker));\n          }\n          processedValue = `${base}${processedValue.substring(processedValue.indexOf(decimalMarker), processedValue.length)}`;\n        }\n        let value = '';\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        this.allowNegativeNumbers && processedValue.slice(cursor, cursor + 1) === MaskExpression.MINUS ? value = `${MaskExpression.MINUS}${processedValue.slice(cursor + 1, cursor + processedValue.length)}` : value = processedValue;\n        if (this.percentage(value)) {\n          result = this._splitPercentZero(processedValue);\n        } else {\n          result = this._splitPercentZero(processedValue.substring(0, processedValue.length - 1));\n        }\n      } else if (maskExpression.startsWith(MaskExpression.SEPARATOR)) {\n        if (processedValue.match('[wа-яА-Я]') || processedValue.match('[ЁёА-я]') || processedValue.match('[a-z]|[A-Z]') || processedValue.match(/[-@#!$%\\\\^&*()_£¬'+|~=`{}\\]:\";<>.?/]/) || processedValue.match('[^A-Za-z0-9,]')) {\n          processedValue = this._stripToDecimal(processedValue);\n        }\n        const precision = this.getPrecision(maskExpression);\n        let decimalMarker = this.decimalMarker;\n        if (Array.isArray(this.decimalMarker)) {\n          if (this.actualValue.includes(this.decimalMarker[0]) || this.actualValue.includes(this.decimalMarker[1])) {\n            decimalMarker = this.actualValue.includes(this.decimalMarker[0]) ? this.decimalMarker[0] : this.decimalMarker[1];\n          } else {\n            decimalMarker = this.decimalMarker.find(dm => dm !== this.thousandSeparator);\n          }\n        }\n        if (backspaced) {\n          const {\n            decimalMarkerIndex,\n            nonZeroIndex\n          } = this._findFirstNonZeroAndDecimalIndex(processedValue, decimalMarker);\n          const zeroIndexMinus = processedValue[0] === MaskExpression.MINUS;\n          const zeroIndexNumberZero = processedValue[0] === MaskExpression.NUMBER_ZERO;\n          const zeroIndexDecimalMarker = processedValue[0] === decimalMarker;\n          const firstIndexDecimalMarker = processedValue[1] === decimalMarker;\n          if (zeroIndexDecimalMarker && !nonZeroIndex || zeroIndexMinus && firstIndexDecimalMarker && !nonZeroIndex || zeroIndexNumberZero && !decimalMarkerIndex && !nonZeroIndex) {\n            processedValue = MaskExpression.NUMBER_ZERO;\n          }\n          if (decimalMarkerIndex && nonZeroIndex && zeroIndexMinus && processedPosition === 1) {\n            if (decimalMarkerIndex < nonZeroIndex || decimalMarkerIndex > nonZeroIndex) {\n              processedValue = MaskExpression.MINUS + processedValue.slice(nonZeroIndex);\n            }\n          }\n          if (!decimalMarkerIndex && nonZeroIndex && processedValue.length > nonZeroIndex) {\n            processedValue = zeroIndexMinus ? MaskExpression.MINUS + processedValue.slice(nonZeroIndex) : processedValue.slice(nonZeroIndex);\n          }\n          if (decimalMarkerIndex && nonZeroIndex && processedPosition === 0) {\n            if (decimalMarkerIndex < nonZeroIndex) {\n              processedValue = processedValue.slice(decimalMarkerIndex - 1);\n            }\n            if (decimalMarkerIndex > nonZeroIndex) {\n              processedValue = processedValue.slice(nonZeroIndex);\n            }\n          }\n        }\n        if (precision === 0) {\n          processedValue = this.allowNegativeNumbers ? processedValue.length > 2 && processedValue[0] === MaskExpression.MINUS && processedValue[1] === MaskExpression.NUMBER_ZERO && processedValue[2] !== this.thousandSeparator && processedValue[2] !== MaskExpression.COMMA && processedValue[2] !== MaskExpression.DOT ? '-' + processedValue.slice(2, processedValue.length) : processedValue[0] === MaskExpression.NUMBER_ZERO && processedValue.length > 1 && processedValue[1] !== this.thousandSeparator && processedValue[1] !== MaskExpression.COMMA && processedValue[1] !== MaskExpression.DOT ? processedValue.slice(1, processedValue.length) : processedValue : processedValue.length > 1 && processedValue[0] === MaskExpression.NUMBER_ZERO && processedValue[1] !== this.thousandSeparator && processedValue[1] !== MaskExpression.COMMA && processedValue[1] !== MaskExpression.DOT ? processedValue.slice(1, processedValue.length) : processedValue;\n        } else {\n          if (processedValue[0] === decimalMarker && processedValue.length > 1 && !backspaced) {\n            processedValue = MaskExpression.NUMBER_ZERO + processedValue.slice(0, processedValue.length + 1);\n            this.plusOnePosition = true;\n          }\n          if (processedValue[0] === MaskExpression.NUMBER_ZERO && processedValue[1] !== decimalMarker && processedValue[1] !== this.thousandSeparator && !backspaced) {\n            processedValue = processedValue.length > 1 ? processedValue.slice(0, 1) + decimalMarker + processedValue.slice(1, processedValue.length + 1) : processedValue;\n            this.plusOnePosition = true;\n          }\n          if (this.allowNegativeNumbers && !backspaced && processedValue[0] === MaskExpression.MINUS && (processedValue[1] === decimalMarker || processedValue[1] === MaskExpression.NUMBER_ZERO)) {\n            processedValue = processedValue[1] === decimalMarker && processedValue.length > 2 ? processedValue.slice(0, 1) + MaskExpression.NUMBER_ZERO + processedValue.slice(1, processedValue.length) : processedValue[1] === MaskExpression.NUMBER_ZERO && processedValue.length > 2 && processedValue[2] !== decimalMarker ? processedValue.slice(0, 2) + decimalMarker + processedValue.slice(2, processedValue.length) : processedValue;\n            this.plusOnePosition = true;\n          }\n        }\n        // TODO: we had different rexexps here for the different cases... but tests dont seam to bother - check this\n        //  separator: no COMMA, dot-sep: no SPACE, COMMA OK, comma-sep: no SPACE, COMMA OK\n        const thousandSeparatorCharEscaped = this._charToRegExpExpression(this.thousandSeparator);\n        let invalidChars = '@#!$%^&*()_+|~=`{}\\\\[\\\\]:\\\\s,\\\\.\";<>?\\\\/'.replace(thousandSeparatorCharEscaped, '');\n        //.replace(decimalMarkerEscaped, '');\n        if (Array.isArray(this.decimalMarker)) {\n          for (const marker of this.decimalMarker) {\n            invalidChars = invalidChars.replace(this._charToRegExpExpression(marker), MaskExpression.EMPTY_STRING);\n          }\n        } else {\n          invalidChars = invalidChars.replace(this._charToRegExpExpression(this.decimalMarker), '');\n        }\n        const invalidCharRegexp = new RegExp('[' + invalidChars + ']');\n        if (processedValue.match(invalidCharRegexp)) {\n          processedValue = processedValue.substring(0, processedValue.length - 1);\n        }\n        processedValue = this.checkInputPrecision(processedValue, precision, this.decimalMarker);\n        const strForSep = processedValue.replace(new RegExp(thousandSeparatorCharEscaped, 'g'), '');\n        result = this._formatWithSeparators(strForSep, this.thousandSeparator, this.decimalMarker, precision);\n        const commaShift = result.indexOf(MaskExpression.COMMA) - processedValue.indexOf(MaskExpression.COMMA);\n        const shiftStep = result.length - processedValue.length;\n        const backspacedDecimalMarkerWithSeparatorLimit = backspaced && result.length < inputValue.length - this.suffix.length && this.separatorLimit;\n        if ((result[processedPosition - 1] === this.thousandSeparator || result[processedPosition - this.prefix.length]) && this.prefix && backspaced) {\n          processedPosition = processedPosition - 1;\n        } else if (shiftStep > 0 && result[processedPosition] !== this.thousandSeparator || backspacedDecimalMarkerWithSeparatorLimit) {\n          backspaceShift = true;\n          let _shift = 0;\n          do {\n            this._shift.add(processedPosition + _shift);\n            _shift++;\n          } while (_shift < shiftStep);\n        } else if (result[processedPosition - 1] === this.thousandSeparator || shiftStep === -4 || shiftStep === -3 || result[processedPosition] === this.thousandSeparator) {\n          this._shift.clear();\n          this._shift.add(processedPosition - 1);\n        } else if (commaShift !== 0 && processedPosition > 0 && !(result.indexOf(MaskExpression.COMMA) >= processedPosition && processedPosition > 3) || !(result.indexOf(MaskExpression.DOT) >= processedPosition && processedPosition > 3) && shiftStep <= 0) {\n          this._shift.clear();\n          backspaceShift = true;\n          shift = shiftStep;\n          processedPosition += shiftStep;\n          this._shift.add(processedPosition);\n        } else {\n          this._shift.clear();\n        }\n      } else {\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        let i = 0, inputSymbol = inputArray[0]; i < inputArray.length; i++, inputSymbol = inputArray[i] ?? MaskExpression.EMPTY_STRING) {\n          if (cursor === maskExpression.length) {\n            break;\n          }\n          const symbolStarInPattern = MaskExpression.SYMBOL_STAR in this.patterns;\n          if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) && maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION) {\n            result += inputSymbol;\n            cursor += 2;\n          } else if (maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR && multi && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING)) {\n            result += inputSymbol;\n            cursor += 3;\n            multi = false;\n          } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) && maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR && !symbolStarInPattern) {\n            result += inputSymbol;\n            multi = true;\n          } else if (maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING)) {\n            result += inputSymbol;\n            cursor += 3;\n          } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? MaskExpression.EMPTY_STRING)) {\n            if (maskExpression[cursor] === MaskExpression.HOURS) {\n              if (this.apm ? Number(inputSymbol) > 9 : Number(inputSymbol) > 2) {\n                processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n                cursor += 1;\n                this._shiftStep(cursor);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === MaskExpression.HOUR) {\n              if (this.apm ? result.length === 1 && Number(result) > 1 || result === '1' && Number(inputSymbol) > 2 || processedValue.slice(cursor - 1, cursor).length === 1 && Number(processedValue.slice(cursor - 1, cursor)) > 2 || processedValue.slice(cursor - 1, cursor) === '1' && Number(inputSymbol) > 2 : result === '2' && Number(inputSymbol) > 3 || (result.slice(cursor - 2, cursor) === '2' || result.slice(cursor - 3, cursor) === '2' || result.slice(cursor - 4, cursor) === '2' || result.slice(cursor - 1, cursor) === '2') && Number(inputSymbol) > 3 && cursor > 10) {\n                processedPosition = processedPosition + 1;\n                cursor += 1;\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === MaskExpression.MINUTE || maskExpression[cursor] === MaskExpression.SECOND) {\n              if (Number(inputSymbol) > 5) {\n                processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n                cursor += 1;\n                this._shiftStep(cursor);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            const daysCount = 31;\n            const inputValueCursor = processedValue[cursor];\n            const inputValueCursorPlusOne = processedValue[cursor + 1];\n            const inputValueCursorPlusTwo = processedValue[cursor + 2];\n            const inputValueCursorMinusOne = processedValue[cursor - 1];\n            const inputValueCursorMinusTwo = processedValue[cursor - 2];\n            const inputValueSliceMinusThreeMinusOne = processedValue.slice(cursor - 3, cursor - 1);\n            const inputValueSliceMinusOnePlusOne = processedValue.slice(cursor - 1, cursor + 1);\n            const inputValueSliceCursorPlusTwo = processedValue.slice(cursor, cursor + 2);\n            const inputValueSliceMinusTwoCursor = processedValue.slice(cursor - 2, cursor);\n            if (maskExpression[cursor] === MaskExpression.DAY) {\n              const maskStartWithMonth = maskExpression.slice(0, 2) === MaskExpression.MONTHS;\n              const startWithMonthInput = maskExpression.slice(0, 2) === MaskExpression.MONTHS && this.specialCharacters.includes(inputValueCursorMinusTwo);\n              if (Number(inputSymbol) > 3 && this.leadZeroDateTime || !maskStartWithMonth && (Number(inputValueSliceCursorPlusTwo) > daysCount || Number(inputValueSliceMinusOnePlusOne) > daysCount || this.specialCharacters.includes(inputValueCursorPlusOne)) || (startWithMonthInput ? Number(inputValueSliceMinusOnePlusOne) > daysCount || !this.specialCharacters.includes(inputValueCursor) && this.specialCharacters.includes(inputValueCursorPlusTwo) || this.specialCharacters.includes(inputValueCursor) : Number(inputValueSliceCursorPlusTwo) > daysCount || this.specialCharacters.includes(inputValueCursorPlusOne) && !backspaced)) {\n                processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n                cursor += 1;\n                this._shiftStep(cursor);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === MaskExpression.MONTH) {\n              const monthsCount = 12;\n              // mask without day\n              const withoutDays = cursor === 0 && (Number(inputSymbol) > 2 || Number(inputValueSliceCursorPlusTwo) > monthsCount || this.specialCharacters.includes(inputValueCursorPlusOne) && !backspaced);\n              // day<10 && month<12 for input\n              const specialChart = maskExpression.slice(cursor + 2, cursor + 3);\n              const day1monthInput = inputValueSliceMinusThreeMinusOne.includes(specialChart) && maskExpression.includes('d0') && (this.specialCharacters.includes(inputValueCursorMinusTwo) && Number(inputValueSliceMinusOnePlusOne) > monthsCount && !this.specialCharacters.includes(inputValueCursor) || this.specialCharacters.includes(inputValueCursor));\n              //  month<12 && day<10 for input\n              const day2monthInput = Number(inputValueSliceMinusThreeMinusOne) <= daysCount && !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) && this.specialCharacters.includes(inputValueCursorMinusOne) && (Number(inputValueSliceCursorPlusTwo) > monthsCount || this.specialCharacters.includes(inputValueCursorPlusOne));\n              // cursor === 5 && without days\n              const day2monthInputDot = Number(inputValueSliceCursorPlusTwo) > monthsCount && cursor === 5 || this.specialCharacters.includes(inputValueCursorPlusOne) && cursor === 5;\n              // // day<10 && month<12 for paste whole data\n              const day1monthPaste = Number(inputValueSliceMinusThreeMinusOne) > daysCount && !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) && !this.specialCharacters.includes(inputValueSliceMinusTwoCursor) && Number(inputValueSliceMinusTwoCursor) > monthsCount && maskExpression.includes('d0');\n              // 10<day<31 && month<12 for paste whole data\n              const day2monthPaste = Number(inputValueSliceMinusThreeMinusOne) <= daysCount && !this.specialCharacters.includes(inputValueSliceMinusThreeMinusOne) && !this.specialCharacters.includes(inputValueCursorMinusOne) && Number(inputValueSliceMinusOnePlusOne) > monthsCount;\n              if (Number(inputSymbol) > 1 && this.leadZeroDateTime || withoutDays || day1monthInput || day2monthPaste || day1monthPaste || day2monthInput || day2monthInputDot && !this.leadZeroDateTime) {\n                processedPosition = !this.leadZeroDateTime ? processedPosition + 1 : processedPosition;\n                cursor += 1;\n                this._shiftStep(cursor);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            result += inputSymbol;\n            cursor++;\n          } else if (this.specialCharacters.includes(inputSymbol) && maskExpression[cursor] === inputSymbol) {\n            result += inputSymbol;\n            cursor++;\n          } else if (this.specialCharacters.indexOf(maskExpression[cursor] ?? MaskExpression.EMPTY_STRING) !== -1) {\n            result += maskExpression[cursor];\n            cursor++;\n            this._shiftStep(cursor);\n            i--;\n          } else if (maskExpression[cursor] === MaskExpression.NUMBER_NINE && this.showMaskTyped) {\n            this._shiftStep(cursor);\n          } else if (this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING] && this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING]?.optional) {\n            if (!!inputArray[cursor] && maskExpression !== '099.099.099.099' && maskExpression !== '000.000.000-00' && maskExpression !== '00.000.000/0000-00' && !maskExpression.match(/^9+\\.0+$/) && !this.patterns[maskExpression[cursor] ?? MaskExpression.EMPTY_STRING]?.optional) {\n              result += inputArray[cursor];\n            }\n            if (maskExpression.includes(MaskExpression.NUMBER_NINE + MaskExpression.SYMBOL_STAR) && maskExpression.includes(MaskExpression.NUMBER_ZERO + MaskExpression.SYMBOL_STAR)) {\n              cursor++;\n            }\n            cursor++;\n            i--;\n          } else if (this.maskExpression[cursor + 1] === MaskExpression.SYMBOL_STAR && this._findSpecialChar(this.maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING) && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n            cursor += 3;\n            result += inputSymbol;\n          } else if (this.maskExpression[cursor + 1] === MaskExpression.SYMBOL_QUESTION && this._findSpecialChar(this.maskExpression[cursor + 2] ?? MaskExpression.EMPTY_STRING) && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n            cursor += 3;\n            result += inputSymbol;\n          } else if (this.showMaskTyped && this.specialCharacters.indexOf(inputSymbol) < 0 && inputSymbol !== this.placeHolderCharacter && this.placeHolderCharacter.length === 1) {\n            stepBack = true;\n          }\n        }\n      }\n      if (result[processedPosition - 1] && result.length + 1 === maskExpression.length && this.specialCharacters.indexOf(maskExpression[maskExpression.length - 1] ?? MaskExpression.EMPTY_STRING) !== -1) {\n        result += maskExpression[maskExpression.length - 1];\n      }\n      let newPosition = processedPosition + 1;\n      while (this._shift.has(newPosition)) {\n        shift++;\n        newPosition++;\n      }\n      let actualShift = justPasted && !maskExpression.startsWith(MaskExpression.SEPARATOR) ? cursor : this._shift.has(processedPosition) ? shift : 0;\n      if (stepBack) {\n        actualShift--;\n      }\n      cb(actualShift, backspaceShift);\n      if (shift < 0) {\n        this._shift.clear();\n      }\n      let onlySpecial = false;\n      if (backspaced) {\n        onlySpecial = inputArray.every(char => this.specialCharacters.includes(char));\n      }\n      let res = `${this.prefix}${onlySpecial ? MaskExpression.EMPTY_STRING : result}${this.showMaskTyped ? '' : this.suffix}`;\n      if (result.length === 0) {\n        res = this.instantPrefix ? `${this.prefix}${result}` : `${result}`;\n      }\n      const isSpecialCharacterMaskFirstSymbol = processedValue.length === 1 && this.specialCharacters.includes(maskExpression[0]) && processedValue !== maskExpression[0];\n      if (!this._checkSymbolMask(processedValue, maskExpression[1]) && isSpecialCharacterMaskFirstSymbol) {\n        return '';\n      }\n      if (result.includes(MaskExpression.MINUS) && this.prefix && this.allowNegativeNumbers) {\n        if (backspaced && result === MaskExpression.MINUS) {\n          return '';\n        }\n        res = `${MaskExpression.MINUS}${this.prefix}${result.split(MaskExpression.MINUS).join(MaskExpression.EMPTY_STRING)}${this.suffix}`;\n      }\n      return res;\n    }\n    _findDropSpecialChar(inputSymbol) {\n      if (Array.isArray(this.dropSpecialCharacters)) {\n        return this.dropSpecialCharacters.find(val => val === inputSymbol);\n      }\n      return this._findSpecialChar(inputSymbol);\n    }\n    _findSpecialChar(inputSymbol) {\n      return this.specialCharacters.find(val => val === inputSymbol);\n    }\n    _checkSymbolMask(inputSymbol, maskSymbol) {\n      this.patterns = this.customPattern ? this.customPattern : this.patterns;\n      return (this.patterns[maskSymbol]?.pattern && this.patterns[maskSymbol]?.pattern.test(inputSymbol)) ?? false;\n    }\n    _formatWithSeparators = (str, thousandSeparatorChar, decimalChars, precision) => {\n      let x = [];\n      let decimalChar = '';\n      if (Array.isArray(decimalChars)) {\n        const regExp = new RegExp(decimalChars.map(v => '[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v).join('|'));\n        x = str.split(regExp);\n        decimalChar = str.match(regExp)?.[0] ?? MaskExpression.EMPTY_STRING;\n      } else {\n        x = str.split(decimalChars);\n        decimalChar = decimalChars;\n      }\n      const decimals = x.length > 1 ? `${decimalChar}${x[1]}` : MaskExpression.EMPTY_STRING;\n      let res = x[0] ?? MaskExpression.EMPTY_STRING;\n      const separatorLimit = this.separatorLimit.replace(/\\s/g, MaskExpression.EMPTY_STRING);\n      if (separatorLimit && +separatorLimit) {\n        if (res[0] === MaskExpression.MINUS) {\n          res = `-${res.slice(1, res.length).slice(0, separatorLimit.length)}`;\n        } else {\n          res = res.slice(0, separatorLimit.length);\n        }\n      }\n      const rgx = /(\\d+)(\\d{3})/;\n      while (thousandSeparatorChar && rgx.test(res)) {\n        res = res.replace(rgx, '$1' + thousandSeparatorChar + '$2');\n      }\n      if (typeof precision === 'undefined') {\n        return res + decimals;\n      } else if (precision === 0) {\n        return res;\n      }\n      return res + decimals.substring(0, precision + 1);\n    };\n    percentage = str => {\n      const sanitizedStr = str.replace(',', '.');\n      const value = Number(this.allowNegativeNumbers && str.includes(MaskExpression.MINUS) ? sanitizedStr.slice(1, str.length) : sanitizedStr);\n      return !isNaN(value) && value >= 0 && value <= 100;\n    };\n    getPrecision = maskExpression => {\n      const x = maskExpression.split(MaskExpression.DOT);\n      if (x.length > 1) {\n        return Number(x[x.length - 1]);\n      }\n      return Infinity;\n    };\n    checkAndRemoveSuffix = inputValue => {\n      for (let i = this.suffix?.length - 1; i >= 0; i--) {\n        const substr = this.suffix.substring(i, this.suffix?.length);\n        if (inputValue.includes(substr) && i !== this.suffix?.length - 1 && (i - 1 < 0 || !inputValue.includes(this.suffix.substring(i - 1, this.suffix?.length)))) {\n          return inputValue.replace(substr, MaskExpression.EMPTY_STRING);\n        }\n      }\n      return inputValue;\n    };\n    checkInputPrecision = (inputValue, precision, decimalMarker) => {\n      let processedInputValue = inputValue;\n      let processedDecimalMarker = decimalMarker;\n      if (precision < Infinity) {\n        // TODO need think about decimalMarker\n        if (Array.isArray(processedDecimalMarker)) {\n          const marker = processedDecimalMarker.find(dm => dm !== this.thousandSeparator);\n          processedDecimalMarker = marker ? marker : processedDecimalMarker[0];\n        }\n        const precisionRegEx = new RegExp(this._charToRegExpExpression(processedDecimalMarker) + `\\\\d{${precision}}.*$`);\n        const precisionMatch = processedInputValue.match(precisionRegEx);\n        const precisionMatchLength = (precisionMatch && precisionMatch[0]?.length) ?? 0;\n        if (precisionMatchLength - 1 > precision) {\n          const diff = precisionMatchLength - 1 - precision;\n          processedInputValue = processedInputValue.substring(0, processedInputValue.length - diff);\n        }\n        if (precision === 0 && this._compareOrIncludes(processedInputValue[processedInputValue.length - 1], processedDecimalMarker, this.thousandSeparator)) {\n          processedInputValue = processedInputValue.substring(0, processedInputValue.length - 1);\n        }\n      }\n      return processedInputValue;\n    };\n    _stripToDecimal(str) {\n      return str.split(MaskExpression.EMPTY_STRING).filter((i, idx) => {\n        const isDecimalMarker = typeof this.decimalMarker === 'string' ? i === this.decimalMarker :\n        // TODO (inepipenko) use utility type\n        this.decimalMarker.includes(i);\n        return i.match('^-?\\\\d') || i === this.thousandSeparator || isDecimalMarker || i === MaskExpression.MINUS && idx === 0 && this.allowNegativeNumbers;\n      }).join(MaskExpression.EMPTY_STRING);\n    }\n    _charToRegExpExpression(char) {\n      // if (Array.isArray(char)) {\n      // \treturn char.map((v) => ('[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v)).join('|');\n      // }\n      if (char) {\n        const charsToEscape = '[\\\\^$.|?*+()';\n        return char === ' ' ? '\\\\s' : charsToEscape.indexOf(char) >= 0 ? `\\\\${char}` : char;\n      }\n      return char;\n    }\n    _shiftStep(cursor) {\n      this._shift.add(cursor + this.prefix.length || 0);\n    }\n    _compareOrIncludes(value, comparedValue, excludedValue) {\n      return Array.isArray(comparedValue) ? comparedValue.filter(v => v !== excludedValue).includes(value) : value === comparedValue;\n    }\n    _validIP(valuesIP) {\n      return !(valuesIP.length === 4 && !valuesIP.some((value, index) => {\n        if (valuesIP.length !== index + 1) {\n          return value === MaskExpression.EMPTY_STRING || Number(value) > 255;\n        }\n        return value === MaskExpression.EMPTY_STRING || Number(value.substring(0, 3)) > 255;\n      }));\n    }\n    _splitPercentZero(value) {\n      if (value === MaskExpression.MINUS && this.allowNegativeNumbers) {\n        return value;\n      }\n      const decimalIndex = typeof this.decimalMarker === 'string' ? value.indexOf(this.decimalMarker) : value.indexOf(MaskExpression.DOT);\n      const emptyOrMinus = this.allowNegativeNumbers && value.includes(MaskExpression.MINUS) ? '-' : '';\n      if (decimalIndex === -1) {\n        const parsedValue = parseInt(emptyOrMinus ? value.slice(1, value.length) : value, 10);\n        return isNaN(parsedValue) ? MaskExpression.EMPTY_STRING : `${emptyOrMinus}${parsedValue}`;\n      } else {\n        const integerPart = parseInt(value.replace('-', '').substring(0, decimalIndex), 10);\n        const decimalPart = value.substring(decimalIndex + 1);\n        const integerString = isNaN(integerPart) ? '' : integerPart.toString();\n        const decimal = typeof this.decimalMarker === 'string' ? this.decimalMarker : MaskExpression.DOT;\n        return integerString === MaskExpression.EMPTY_STRING ? MaskExpression.EMPTY_STRING : `${emptyOrMinus}${integerString}${decimal}${decimalPart}`;\n      }\n    }\n    _findFirstNonZeroAndDecimalIndex(inputString, decimalMarker) {\n      let decimalMarkerIndex = null;\n      let nonZeroIndex = null;\n      for (let i = 0; i < inputString.length; i++) {\n        const char = inputString[i];\n        if (char === decimalMarker && decimalMarkerIndex === null) {\n          decimalMarkerIndex = i;\n        }\n        if (char && char >= '1' && char <= '9' && nonZeroIndex === null) {\n          nonZeroIndex = i;\n        }\n        if (decimalMarkerIndex !== null && nonZeroIndex !== null) {\n          break;\n        }\n      }\n      return {\n        decimalMarkerIndex,\n        nonZeroIndex\n      };\n    }\n    static ɵfac = function NgxMaskApplierService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxMaskApplierService)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgxMaskApplierService,\n      factory: NgxMaskApplierService.ɵfac\n    });\n  }\n  return NgxMaskApplierService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMaskService = /*#__PURE__*/(() => {\n  class NgxMaskService extends NgxMaskApplierService {\n    isNumberValue = false;\n    maskIsShown = '';\n    selStart = null;\n    selEnd = null;\n    maskChanged = false;\n    maskExpressionArray = [];\n    previousValue = '';\n    currentValue = '';\n    /**\n     * Whether we are currently in writeValue function, in this case when applying the mask we don't want to trigger onChange function,\n     * since writeValue should be a one way only process of writing the DOM value based on the Angular model value.\n     */\n    writingValue = false;\n    isInitialized = false;\n    _emitValue = false;\n    _start;\n    _end;\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onChange = _ => {};\n    _elementRef = inject(ElementRef, {\n      optional: true\n    });\n    document = inject(DOCUMENT);\n    _config = inject(NGX_MASK_CONFIG);\n    _renderer = inject(Renderer2, {\n      optional: true\n    });\n    /**\n     * Applies the mask to the input value.\n     * @param inputValue The input value to be masked.\n     * @param maskExpression The mask expression to apply.\n     * @param position The position in the input value.\n     * @param justPasted Whether the value was just pasted.\n     * @param backspaced Whether the value was backspaced.\n     * @param cb Callback function.\n     * @returns The masked value.\n     */\n    applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    cb = () => {}) {\n      // If no mask expression, return the input value or the actual value\n      if (!maskExpression) {\n        return inputValue !== this.actualValue ? this.actualValue : inputValue;\n      }\n      // Show mask in input if required\n      this.maskIsShown = this.showMaskTyped ? this.showMaskInInput() : MaskExpression.EMPTY_STRING;\n      // Handle specific mask expressions\n      if (this.maskExpression === MaskExpression.IP && this.showMaskTyped) {\n        this.maskIsShown = this.showMaskInInput(inputValue || MaskExpression.HASH);\n      }\n      if (this.maskExpression === MaskExpression.CPF_CNPJ && this.showMaskTyped) {\n        this.maskIsShown = this.showMaskInInput(inputValue || MaskExpression.HASH);\n      }\n      // Handle empty input value with mask typed\n      if (!inputValue && this.showMaskTyped) {\n        this.formControlResult(this.prefix);\n        return `${this.prefix}${this.maskIsShown}${this.suffix}`;\n      }\n      const getSymbol = !!inputValue && typeof this.selStart === 'number' ? inputValue[this.selStart] ?? MaskExpression.EMPTY_STRING : MaskExpression.EMPTY_STRING;\n      let newInputValue = '';\n      let newPosition = position;\n      // Handle hidden input or input with asterisk symbol\n      if ((this.hiddenInput || inputValue && inputValue.indexOf(MaskExpression.SYMBOL_STAR) >= 0) && !this.writingValue) {\n        let actualResult = inputValue && inputValue.length === 1 ? inputValue.split(MaskExpression.EMPTY_STRING) : this.actualValue.split(MaskExpression.EMPTY_STRING);\n        // Handle backspace\n        if (backspaced) {\n          actualResult = actualResult.slice(0, position).concat(actualResult.slice(position + 1));\n        }\n        // Remove mask if showMaskTyped is true\n        if (this.showMaskTyped) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = this.removeMask(inputValue);\n          actualResult = this.removeMask(actualResult.join('')).split(MaskExpression.EMPTY_STRING);\n        }\n        // Handle selection start and end\n        if (typeof this.selStart === 'object' && typeof this.selEnd === 'object') {\n          this.selStart = Number(this.selStart);\n          this.selEnd = Number(this.selEnd);\n        } else {\n          if (inputValue !== MaskExpression.EMPTY_STRING && actualResult.length) {\n            if (typeof this.selStart === 'number' && typeof this.selEnd === 'number') {\n              if (inputValue.length > actualResult.length) {\n                actualResult.splice(this.selStart, 0, getSymbol);\n              } else if (inputValue.length < actualResult.length) {\n                if (actualResult.length - inputValue.length === 1) {\n                  if (backspaced) {\n                    actualResult.splice(this.selStart - 1, 1);\n                  } else {\n                    actualResult.splice(inputValue.length - 1, 1);\n                  }\n                } else {\n                  actualResult.splice(this.selStart, this.selEnd - this.selStart);\n                }\n              }\n            }\n          } else {\n            actualResult = [];\n          }\n        }\n        // Remove mask if showMaskTyped is true and hiddenInput is false\n        if (this.showMaskTyped && !this.hiddenInput) {\n          newInputValue = this.removeMask(inputValue);\n        }\n        // Handle actual value length\n        if (this.actualValue.length) {\n          if (actualResult.length < inputValue.length) {\n            newInputValue = this.shiftTypedSymbols(actualResult.join(MaskExpression.EMPTY_STRING));\n          } else if (actualResult.length === inputValue.length) {\n            newInputValue = actualResult.join(MaskExpression.EMPTY_STRING);\n          } else {\n            newInputValue = inputValue;\n          }\n        } else {\n          newInputValue = inputValue;\n        }\n      }\n      // Handle just pasted input\n      if (justPasted && (this.hiddenInput || !this.hiddenInput)) {\n        newInputValue = inputValue;\n      }\n      // Handle backspace with special characters\n      if (backspaced && this.specialCharacters.indexOf(this.maskExpression[newPosition] ?? MaskExpression.EMPTY_STRING) !== -1 && this.showMaskTyped && !this.prefix) {\n        newInputValue = this.currentValue;\n      }\n      // Handle deleted special character\n      if (this.deletedSpecialCharacter && newPosition) {\n        if (this.specialCharacters.includes(this.actualValue.slice(newPosition, newPosition + 1))) {\n          newPosition = newPosition + 1;\n        } else if (maskExpression.slice(newPosition - 1, newPosition + 1) !== MaskExpression.MONTHS) {\n          newPosition = newPosition - 2;\n        }\n        this.deletedSpecialCharacter = false;\n      }\n      // Remove mask if showMaskTyped is true and placeHolderCharacter length is 1\n      if (this.showMaskTyped && this.placeHolderCharacter.length === 1 && !this.leadZeroDateTime) {\n        newInputValue = this.removeMask(newInputValue);\n      }\n      // Handle mask changed\n      if (this.maskChanged) {\n        newInputValue = inputValue;\n      } else {\n        newInputValue = Boolean(newInputValue) && newInputValue.length ? newInputValue : inputValue;\n      }\n      // Handle showMaskTyped and keepCharacterPositions\n      if (this.showMaskTyped && this.keepCharacterPositions && this.actualValue && !justPasted && !this.writingValue) {\n        const value = this.dropSpecialCharacters ? this.removeMask(this.actualValue) : this.actualValue;\n        this.formControlResult(value);\n        return this.actualValue ? this.actualValue : `${this.prefix}${this.maskIsShown}${this.suffix}`;\n      }\n      // Apply the mask using the parent class method\n      const result = super.applyMask(newInputValue, maskExpression, newPosition, justPasted, backspaced, cb);\n      this.actualValue = this.getActualValue(result);\n      // handle some separator implications:\n      // a.) adjust decimalMarker default (. -> ,) if thousandSeparator is a dot\n      if (this.thousandSeparator === MaskExpression.DOT && this.decimalMarker === MaskExpression.DOT) {\n        this.decimalMarker = MaskExpression.COMMA;\n      }\n      // b) remove decimal marker from list of special characters to mask\n      if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && this.dropSpecialCharacters === true) {\n        this.specialCharacters = this.specialCharacters.filter(item => !this._compareOrIncludes(item, this.decimalMarker, this.thousandSeparator) //item !== this.decimalMarker, // !\n        );\n      }\n      // Update previous and current values\n      if (result || result === '') {\n        this.previousValue = this.currentValue;\n        this.currentValue = result;\n        this._emitValue = this.previousValue !== this.currentValue || this.previousValue === this.currentValue && justPasted;\n      }\n      // Propagate the input value back to the Angular model\n      // eslint-disable-next-line no-unused-expressions,@typescript-eslint/no-unused-expressions\n      this._emitValue ? this.formControlResult(result) : '';\n      // Handle hidden input and showMaskTyped\n      if (!this.showMaskTyped || this.showMaskTyped && this.hiddenInput) {\n        if (this.hiddenInput) {\n          return `${this.hideInput(result, this.maskExpression)}${this.maskIsShown.slice(result.length)}`;\n        }\n        return result;\n      }\n      const resLen = result.length;\n      const prefNmask = `${this.prefix}${this.maskIsShown}${this.suffix}`;\n      // Handle specific mask expressions\n      if (this.maskExpression.includes(MaskExpression.HOURS)) {\n        const countSkipedSymbol = this._numberSkipedSymbols(result);\n        return `${result}${prefNmask.slice(resLen + countSkipedSymbol)}`;\n      } else if (this.maskExpression === MaskExpression.IP || this.maskExpression === MaskExpression.CPF_CNPJ) {\n        return `${result}${prefNmask}`;\n      }\n      return `${result}${prefNmask.slice(resLen)}`;\n    }\n    // get the number of characters that were shifted\n    _numberSkipedSymbols(value) {\n      const regex = /(^|\\D)(\\d\\D)/g;\n      let match = regex.exec(value);\n      let countSkipedSymbol = 0;\n      while (match != null) {\n        countSkipedSymbol += 1;\n        match = regex.exec(value);\n      }\n      return countSkipedSymbol;\n    }\n    applyValueChanges(position, justPasted, backspaced,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    cb = () => {}) {\n      const formElement = this._elementRef?.nativeElement;\n      if (!formElement) {\n        return;\n      }\n      formElement.value = this.applyMask(formElement.value, this.maskExpression, position, justPasted, backspaced, cb);\n      if (formElement === this._getActiveElement()) {\n        return;\n      }\n      this.clearIfNotMatchFn();\n    }\n    hideInput(inputValue, maskExpression) {\n      return inputValue.split(MaskExpression.EMPTY_STRING).map((curr, index) => {\n        if (this.patterns && this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING] && this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING]?.symbol) {\n          return this.patterns[maskExpression[index] ?? MaskExpression.EMPTY_STRING]?.symbol;\n        }\n        return curr;\n      }).join(MaskExpression.EMPTY_STRING);\n    }\n    // this function is not necessary, it checks result against maskExpression\n    getActualValue(res) {\n      const compare = res.split(MaskExpression.EMPTY_STRING).filter((symbol, i) => {\n        const maskChar = this.maskExpression[i] ?? MaskExpression.EMPTY_STRING;\n        return this._checkSymbolMask(symbol, maskChar) || this.specialCharacters.includes(maskChar) && symbol === maskChar;\n      });\n      if (compare.join(MaskExpression.EMPTY_STRING) === res) {\n        return compare.join(MaskExpression.EMPTY_STRING);\n      }\n      return res;\n    }\n    shiftTypedSymbols(inputValue) {\n      let symbolToReplace = '';\n      const newInputValue = inputValue && inputValue.split(MaskExpression.EMPTY_STRING).map((currSymbol, index) => {\n        if (this.specialCharacters.includes(inputValue[index + 1] ?? MaskExpression.EMPTY_STRING) && inputValue[index + 1] !== this.maskExpression[index + 1]) {\n          symbolToReplace = currSymbol;\n          return inputValue[index + 1];\n        }\n        if (symbolToReplace.length) {\n          const replaceSymbol = symbolToReplace;\n          symbolToReplace = MaskExpression.EMPTY_STRING;\n          return replaceSymbol;\n        }\n        return currSymbol;\n      }) || [];\n      return newInputValue.join(MaskExpression.EMPTY_STRING);\n    }\n    /**\n     * Convert number value to string\n     * 3.1415 -> '3.1415'\n     * 1e-7 -> '0.0000001'\n     */\n    numberToString(value) {\n      if (!value && value !== 0 || this.maskExpression.startsWith(MaskExpression.SEPARATOR) && (this.leadZero || !this.dropSpecialCharacters) || this.maskExpression.startsWith(MaskExpression.SEPARATOR) && this.separatorLimit.length > 14 && String(value).length > 14) {\n        return String(value);\n      }\n      return Number(value).toLocaleString('fullwide', {\n        useGrouping: false,\n        maximumFractionDigits: 20\n      }).replace(`/${MaskExpression.MINUS}/`, MaskExpression.MINUS);\n    }\n    showMaskInInput(inputVal) {\n      if (this.showMaskTyped && !!this.shownMaskExpression) {\n        if (this.maskExpression.length !== this.shownMaskExpression.length) {\n          throw new Error('Mask expression must match mask placeholder length');\n        } else {\n          return this.shownMaskExpression;\n        }\n      } else if (this.showMaskTyped) {\n        if (inputVal) {\n          if (this.maskExpression === MaskExpression.IP) {\n            return this._checkForIp(inputVal);\n          }\n          if (this.maskExpression === MaskExpression.CPF_CNPJ) {\n            return this._checkForCpfCnpj(inputVal);\n          }\n        }\n        if (this.placeHolderCharacter.length === this.maskExpression.length) {\n          return this.placeHolderCharacter;\n        }\n        return this.maskExpression.replace(/\\w/g, this.placeHolderCharacter);\n      }\n      return '';\n    }\n    clearIfNotMatchFn() {\n      const formElement = this._elementRef?.nativeElement;\n      if (!formElement) {\n        return;\n      }\n      if (this.clearIfNotMatch && this.prefix.length + this.maskExpression.length + this.suffix.length !== formElement.value.replace(this.placeHolderCharacter, MaskExpression.EMPTY_STRING).length) {\n        this.formElementProperty = ['value', MaskExpression.EMPTY_STRING];\n        this.applyMask('', this.maskExpression);\n      }\n    }\n    set formElementProperty([name, value]) {\n      if (!this._renderer || !this._elementRef) {\n        return;\n      }\n      //[TODO]: andriikamaldinov1 find better solution\n      Promise.resolve().then(() => this._renderer?.setProperty(this._elementRef?.nativeElement, name, value));\n    }\n    checkDropSpecialCharAmount(mask) {\n      const chars = mask.split(MaskExpression.EMPTY_STRING).filter(item => this._findDropSpecialChar(item));\n      return chars.length;\n    }\n    removeMask(inputValue) {\n      return this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.specialCharacters.concat('_').concat(this.placeHolderCharacter));\n    }\n    _checkForIp(inputVal) {\n      if (inputVal === MaskExpression.HASH) {\n        return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n      }\n      const arr = [];\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < inputVal.length; i++) {\n        const value = inputVal[i] ?? MaskExpression.EMPTY_STRING;\n        if (!value) {\n          continue;\n        }\n        if (value.match('\\\\d')) {\n          arr.push(value);\n        }\n      }\n      if (arr.length <= 3) {\n        return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n      }\n      if (arr.length > 3 && arr.length <= 6) {\n        return `${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n      }\n      if (arr.length > 6 && arr.length <= 9) {\n        return this.placeHolderCharacter;\n      }\n      if (arr.length > 9 && arr.length <= 12) {\n        return '';\n      }\n      return '';\n    }\n    _checkForCpfCnpj(inputVal) {\n      const cpf = `${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n      const cnpj = `${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `/${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n      if (inputVal === MaskExpression.HASH) {\n        return cpf;\n      }\n      const arr = [];\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < inputVal.length; i++) {\n        const value = inputVal[i] ?? MaskExpression.EMPTY_STRING;\n        if (!value) {\n          continue;\n        }\n        if (value.match('\\\\d')) {\n          arr.push(value);\n        }\n      }\n      if (arr.length <= 3) {\n        return cpf.slice(arr.length, cpf.length);\n      }\n      if (arr.length > 3 && arr.length <= 6) {\n        return cpf.slice(arr.length + 1, cpf.length);\n      }\n      if (arr.length > 6 && arr.length <= 9) {\n        return cpf.slice(arr.length + 2, cpf.length);\n      }\n      if (arr.length > 9 && arr.length < 11) {\n        return cpf.slice(arr.length + 3, cpf.length);\n      }\n      if (arr.length === 11) {\n        return '';\n      }\n      if (arr.length === 12) {\n        if (inputVal.length === 17) {\n          return cnpj.slice(16, cnpj.length);\n        }\n        return cnpj.slice(15, cnpj.length);\n      }\n      if (arr.length > 12 && arr.length <= 14) {\n        return cnpj.slice(arr.length + 4, cnpj.length);\n      }\n      return '';\n    }\n    /**\n     * Recursively determine the current active element by navigating the Shadow DOM until the Active Element is found.\n     */\n    _getActiveElement(document = this.document) {\n      const shadowRootEl = document?.activeElement?.shadowRoot;\n      if (!shadowRootEl?.activeElement) {\n        return document.activeElement;\n      } else {\n        return this._getActiveElement(shadowRootEl);\n      }\n    }\n    /**\n     * Propogates the input value back to the Angular model by triggering the onChange function. It won't do this if writingValue\n     * is true. If that is true it means we are currently in the writeValue function, which is supposed to only update the actual\n     * DOM element based on the Angular model value. It should be a one way process, i.e. writeValue should not be modifying the Angular\n     * model value too. Therefore, we don't trigger onChange in this scenario.\n     * @param inputValue the current form input value\n     */\n    formControlResult(inputValue) {\n      const outputTransformFn = this.outputTransformFn ? this.outputTransformFn : v => v;\n      this.writingValue = false;\n      this.maskChanged = false;\n      if (!this.isInitialized && this._emitValue) {\n        return;\n      }\n      if (Array.isArray(this.dropSpecialCharacters)) {\n        this.onChange(outputTransformFn(this._toNumber(this._checkSymbols(this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.dropSpecialCharacters)))));\n      } else if (this.dropSpecialCharacters || !this.dropSpecialCharacters && this.prefix === inputValue) {\n        this.onChange(outputTransformFn(this._toNumber(this._checkSymbols(this._removeSuffix(this._removePrefix(inputValue))))));\n      } else {\n        this.onChange(outputTransformFn(this._toNumber(inputValue)));\n      }\n    }\n    _toNumber(value) {\n      if (!this.isNumberValue || value === MaskExpression.EMPTY_STRING) {\n        return value;\n      }\n      if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && (this.leadZero || !this.dropSpecialCharacters)) {\n        return value;\n      }\n      if (String(value).length > 14 && this.maskExpression.startsWith(MaskExpression.SEPARATOR)) {\n        return String(value);\n      }\n      const num = Number(value);\n      if (this.maskExpression.startsWith(MaskExpression.SEPARATOR) && Number.isNaN(num)) {\n        const val = String(value).replace(',', '.');\n        return Number(val);\n      }\n      return Number.isNaN(num) ? value : num;\n    }\n    _removeMask(value, specialCharactersForRemove) {\n      if (this.maskExpression.startsWith(MaskExpression.PERCENT) && value.includes(MaskExpression.DOT)) {\n        return value;\n      }\n      return value ? value.replace(this._regExpForRemove(specialCharactersForRemove), MaskExpression.EMPTY_STRING) : value;\n    }\n    _removePrefix(value) {\n      if (!this.prefix) {\n        return value;\n      }\n      return value ? value.replace(this.prefix, MaskExpression.EMPTY_STRING) : value;\n    }\n    _removeSuffix(value) {\n      if (!this.suffix) {\n        return value;\n      }\n      return value ? value.replace(this.suffix, MaskExpression.EMPTY_STRING) : value;\n    }\n    _retrieveSeparatorValue(result) {\n      let specialCharacters = Array.isArray(this.dropSpecialCharacters) ? this.specialCharacters.filter(v => {\n        return this.dropSpecialCharacters.includes(v);\n      }) : this.specialCharacters;\n      if (!this.deletedSpecialCharacter && this._checkPatternForSpace() && result.includes(MaskExpression.WHITE_SPACE) && this.maskExpression.includes(MaskExpression.SYMBOL_STAR)) {\n        specialCharacters = specialCharacters.filter(char => char !== MaskExpression.WHITE_SPACE);\n      }\n      return this._removeMask(result, specialCharacters);\n    }\n    _regExpForRemove(specialCharactersForRemove) {\n      return new RegExp(specialCharactersForRemove.map(item => `\\\\${item}`).join('|'), 'gi');\n    }\n    _replaceDecimalMarkerToDot(value) {\n      const markers = Array.isArray(this.decimalMarker) ? this.decimalMarker : [this.decimalMarker];\n      return value.replace(this._regExpForRemove(markers), MaskExpression.DOT);\n    }\n    _checkSymbols(result) {\n      let processedResult = result;\n      if (processedResult === MaskExpression.EMPTY_STRING) {\n        return processedResult;\n      }\n      if (this.maskExpression.startsWith(MaskExpression.PERCENT) && this.decimalMarker === MaskExpression.COMMA) {\n        processedResult = processedResult.replace(MaskExpression.COMMA, MaskExpression.DOT);\n      }\n      const separatorPrecision = this._retrieveSeparatorPrecision(this.maskExpression);\n      const separatorValue = this.specialCharacters.length === 0 ? this._retrieveSeparatorValue(processedResult) : this._replaceDecimalMarkerToDot(this._retrieveSeparatorValue(processedResult));\n      if (!this.isNumberValue) {\n        return separatorValue;\n      }\n      if (separatorPrecision) {\n        if (processedResult === this.decimalMarker) {\n          return null;\n        }\n        if (separatorValue.length > 14) {\n          return String(separatorValue);\n        }\n        return this._checkPrecision(this.maskExpression, separatorValue);\n      } else {\n        return separatorValue;\n      }\n    }\n    _checkPatternForSpace() {\n      for (const key in this.patterns) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.patterns[key] && this.patterns[key]?.hasOwnProperty('pattern')) {\n          const patternString = this.patterns[key]?.pattern.toString();\n          const pattern = this.patterns[key]?.pattern;\n          if (patternString?.includes(MaskExpression.WHITE_SPACE) && pattern?.test(this.maskExpression)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    // TODO should think about helpers or separting decimal precision to own property\n    _retrieveSeparatorPrecision(maskExpretion) {\n      const matcher = maskExpretion.match(new RegExp(`^separator\\\\.([^d]*)`));\n      return matcher ? Number(matcher[1]) : null;\n    }\n    _checkPrecision(separatorExpression, separatorValue) {\n      const separatorPrecision = this.getPrecision(separatorExpression);\n      let value = separatorValue;\n      if (separatorExpression.indexOf('2') > 0 || this.leadZero && Number(separatorPrecision) > 0 && Number.isFinite(separatorPrecision)) {\n        if (this.decimalMarker === MaskExpression.COMMA && this.leadZero) {\n          value = value.replace(',', '.');\n        }\n        return this.leadZero ? Number(value).toFixed(Number(separatorPrecision)) : Number(value).toFixed(2);\n      }\n      return this.numberToString(value);\n    }\n    _repeatPatternSymbols(maskExp) {\n      return maskExp.match(/{[0-9]+}/) && maskExp.split(MaskExpression.EMPTY_STRING).reduce((accum, currVal, index) => {\n        this._start = currVal === MaskExpression.CURLY_BRACKETS_LEFT ? index : this._start;\n        if (currVal !== MaskExpression.CURLY_BRACKETS_RIGHT) {\n          return this._findSpecialChar(currVal) ? accum + currVal : accum;\n        }\n        this._end = index;\n        const repeatNumber = Number(maskExp.slice(this._start + 1, this._end));\n        const replaceWith = new Array(repeatNumber + 1).join(maskExp[this._start - 1]);\n        if (maskExp.slice(0, this._start).length > 1 && maskExp.includes(MaskExpression.LETTER_S)) {\n          const symbols = maskExp.slice(0, this._start - 1);\n          return symbols.includes(MaskExpression.CURLY_BRACKETS_LEFT) ? accum + replaceWith : symbols + accum + replaceWith;\n        } else {\n          return accum + replaceWith;\n        }\n      }, '') || maskExp;\n    }\n    currentLocaleDecimalMarker() {\n      return 1.1.toLocaleString().substring(1, 2);\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵNgxMaskService_BaseFactory;\n      return function NgxMaskService_Factory(__ngFactoryType__) {\n        return (ɵNgxMaskService_BaseFactory || (ɵNgxMaskService_BaseFactory = i0.ɵɵgetInheritedFactory(NgxMaskService)))(__ngFactoryType__ || NgxMaskService);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgxMaskService,\n      factory: NgxMaskService.ɵfac\n    });\n  }\n  return NgxMaskService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @internal\n */\nfunction _configFactory() {\n  const initConfig = inject(INITIAL_CONFIG);\n  const configValue = inject(NEW_CONFIG);\n  return configValue instanceof Function ? {\n    ...initConfig,\n    ...configValue()\n  } : {\n    ...initConfig,\n    ...configValue\n  };\n}\nfunction provideNgxMask(configValue) {\n  return [{\n    provide: NEW_CONFIG,\n    useValue: configValue\n  }, {\n    provide: INITIAL_CONFIG,\n    useValue: initialConfig\n  }, {\n    provide: NGX_MASK_CONFIG,\n    useFactory: _configFactory\n  }, NgxMaskService];\n}\nfunction provideEnvironmentNgxMask(configValue) {\n  return makeEnvironmentProviders(provideNgxMask(configValue));\n}\nlet NgxMaskDirective = /*#__PURE__*/(() => {\n  class NgxMaskDirective {\n    mask = input('', ...(ngDevMode ? [{\n      debugName: \"mask\"\n    }] : []));\n    specialCharacters = input([], ...(ngDevMode ? [{\n      debugName: \"specialCharacters\"\n    }] : []));\n    patterns = input({}, ...(ngDevMode ? [{\n      debugName: \"patterns\"\n    }] : []));\n    prefix = input('', ...(ngDevMode ? [{\n      debugName: \"prefix\"\n    }] : []));\n    suffix = input('', ...(ngDevMode ? [{\n      debugName: \"suffix\"\n    }] : []));\n    thousandSeparator = input(' ', ...(ngDevMode ? [{\n      debugName: \"thousandSeparator\"\n    }] : []));\n    decimalMarker = input('.', ...(ngDevMode ? [{\n      debugName: \"decimalMarker\"\n    }] : []));\n    dropSpecialCharacters = input(null, ...(ngDevMode ? [{\n      debugName: \"dropSpecialCharacters\"\n    }] : []));\n    hiddenInput = input(null, ...(ngDevMode ? [{\n      debugName: \"hiddenInput\"\n    }] : []));\n    showMaskTyped = input(null, ...(ngDevMode ? [{\n      debugName: \"showMaskTyped\"\n    }] : []));\n    placeHolderCharacter = input(null, ...(ngDevMode ? [{\n      debugName: \"placeHolderCharacter\"\n    }] : []));\n    shownMaskExpression = input(null, ...(ngDevMode ? [{\n      debugName: \"shownMaskExpression\"\n    }] : []));\n    clearIfNotMatch = input(null, ...(ngDevMode ? [{\n      debugName: \"clearIfNotMatch\"\n    }] : []));\n    validation = input(null, ...(ngDevMode ? [{\n      debugName: \"validation\"\n    }] : []));\n    separatorLimit = input('', ...(ngDevMode ? [{\n      debugName: \"separatorLimit\"\n    }] : []));\n    allowNegativeNumbers = input(null, ...(ngDevMode ? [{\n      debugName: \"allowNegativeNumbers\"\n    }] : []));\n    leadZeroDateTime = input(null, ...(ngDevMode ? [{\n      debugName: \"leadZeroDateTime\"\n    }] : []));\n    leadZero = input(null, ...(ngDevMode ? [{\n      debugName: \"leadZero\"\n    }] : []));\n    triggerOnMaskChange = input(null, ...(ngDevMode ? [{\n      debugName: \"triggerOnMaskChange\"\n    }] : []));\n    apm = input(null, ...(ngDevMode ? [{\n      debugName: \"apm\"\n    }] : []));\n    inputTransformFn = input(null, ...(ngDevMode ? [{\n      debugName: \"inputTransformFn\"\n    }] : []));\n    outputTransformFn = input(null, ...(ngDevMode ? [{\n      debugName: \"outputTransformFn\"\n    }] : []));\n    keepCharacterPositions = input(null, ...(ngDevMode ? [{\n      debugName: \"keepCharacterPositions\"\n    }] : []));\n    instantPrefix = input(null, ...(ngDevMode ? [{\n      debugName: \"instantPrefix\"\n    }] : []));\n    maskFilled = output();\n    _maskValue = signal('', ...(ngDevMode ? [{\n      debugName: \"_maskValue\"\n    }] : []));\n    _inputValue = signal('', ...(ngDevMode ? [{\n      debugName: \"_inputValue\"\n    }] : []));\n    _position = signal(null, ...(ngDevMode ? [{\n      debugName: \"_position\"\n    }] : []));\n    _code = signal('', ...(ngDevMode ? [{\n      debugName: \"_code\"\n    }] : []));\n    _maskExpressionArray = signal([], ...(ngDevMode ? [{\n      debugName: \"_maskExpressionArray\"\n    }] : []));\n    _justPasted = signal(false, ...(ngDevMode ? [{\n      debugName: \"_justPasted\"\n    }] : []));\n    _isFocused = signal(false, ...(ngDevMode ? [{\n      debugName: \"_isFocused\"\n    }] : []));\n    /**For IME composition event */\n    _isComposing = signal(false, ...(ngDevMode ? [{\n      debugName: \"_isComposing\"\n    }] : []));\n    _maskService = inject(NgxMaskService, {\n      self: true\n    });\n    document = inject(DOCUMENT);\n    _config = inject(NGX_MASK_CONFIG);\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onChange = _ => {};\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onTouch = () => {};\n    ngOnChanges(changes) {\n      const {\n        mask,\n        specialCharacters,\n        patterns,\n        prefix,\n        suffix,\n        thousandSeparator,\n        decimalMarker,\n        dropSpecialCharacters,\n        hiddenInput,\n        showMaskTyped,\n        placeHolderCharacter,\n        shownMaskExpression,\n        clearIfNotMatch,\n        validation,\n        separatorLimit,\n        allowNegativeNumbers,\n        leadZeroDateTime,\n        leadZero,\n        triggerOnMaskChange,\n        apm,\n        inputTransformFn,\n        outputTransformFn,\n        keepCharacterPositions,\n        instantPrefix\n      } = changes;\n      if (mask) {\n        if (mask.currentValue !== mask.previousValue && !mask.firstChange) {\n          this._maskService.maskChanged = true;\n        }\n        if (mask.currentValue && mask.currentValue.split(MaskExpression.OR).length > 1) {\n          this._maskExpressionArray.set(mask.currentValue.split(MaskExpression.OR).sort((a, b) => {\n            return a.length - b.length;\n          }));\n          this._setMask();\n        } else {\n          this._maskExpressionArray.set([]);\n          this._maskValue.set(mask.currentValue || MaskExpression.EMPTY_STRING);\n          this._maskService.maskExpression = this._maskValue();\n        }\n      }\n      if (specialCharacters) {\n        if (!specialCharacters.currentValue || !Array.isArray(specialCharacters.currentValue)) {\n          return;\n        } else {\n          this._maskService.specialCharacters = specialCharacters.currentValue || [];\n        }\n      }\n      if (allowNegativeNumbers) {\n        this._maskService.allowNegativeNumbers = allowNegativeNumbers.currentValue;\n        if (this._maskService.allowNegativeNumbers) {\n          this._maskService.specialCharacters = this._maskService.specialCharacters.filter(c => c !== MaskExpression.MINUS);\n        }\n      }\n      // Only overwrite the mask available patterns if a pattern has actually been passed in\n      if (patterns && patterns.currentValue) {\n        this._maskService.patterns = patterns.currentValue;\n      }\n      if (apm && apm.currentValue) {\n        this._maskService.apm = apm.currentValue;\n      }\n      if (instantPrefix) {\n        this._maskService.instantPrefix = instantPrefix.currentValue;\n      }\n      if (prefix) {\n        this._maskService.prefix = prefix.currentValue;\n      }\n      if (suffix) {\n        this._maskService.suffix = suffix.currentValue;\n      }\n      if (thousandSeparator) {\n        this._maskService.thousandSeparator = thousandSeparator.currentValue;\n        if (thousandSeparator.previousValue && thousandSeparator.currentValue) {\n          const previousDecimalMarker = this._maskService.decimalMarker;\n          if (thousandSeparator.currentValue === this._maskService.decimalMarker) {\n            this._maskService.decimalMarker = thousandSeparator.currentValue === MaskExpression.COMMA ? MaskExpression.DOT : MaskExpression.COMMA;\n          }\n          if (this._maskService.dropSpecialCharacters === true) {\n            this._maskService.specialCharacters = this._config.specialCharacters;\n          }\n          if (typeof previousDecimalMarker === 'string' && typeof this._maskService.decimalMarker === 'string') {\n            this._inputValue.set(this._inputValue().split(thousandSeparator.previousValue).join('').replace(previousDecimalMarker, this._maskService.decimalMarker));\n            this._maskService.actualValue = this._inputValue();\n          }\n          this._maskService.writingValue = true;\n        }\n      }\n      if (decimalMarker) {\n        this._maskService.decimalMarker = decimalMarker.currentValue;\n      }\n      if (dropSpecialCharacters) {\n        this._maskService.dropSpecialCharacters = dropSpecialCharacters.currentValue;\n      }\n      if (hiddenInput) {\n        this._maskService.hiddenInput = hiddenInput.currentValue;\n        if (hiddenInput.previousValue === true && hiddenInput.currentValue === false) {\n          this._inputValue.set(this._maskService.actualValue);\n        }\n      }\n      if (showMaskTyped) {\n        this._maskService.showMaskTyped = showMaskTyped.currentValue;\n        if (showMaskTyped.previousValue === false && showMaskTyped.currentValue === true && this._isFocused()) {\n          requestAnimationFrame(() => {\n            this._maskService._elementRef?.nativeElement.click();\n          });\n        }\n      }\n      if (placeHolderCharacter) {\n        this._maskService.placeHolderCharacter = placeHolderCharacter.currentValue;\n      }\n      if (shownMaskExpression) {\n        this._maskService.shownMaskExpression = shownMaskExpression.currentValue;\n      }\n      if (clearIfNotMatch) {\n        this._maskService.clearIfNotMatch = clearIfNotMatch.currentValue;\n      }\n      if (validation) {\n        this._maskService.validation = validation.currentValue;\n      }\n      if (separatorLimit) {\n        this._maskService.separatorLimit = separatorLimit.currentValue;\n      }\n      if (leadZeroDateTime) {\n        this._maskService.leadZeroDateTime = leadZeroDateTime.currentValue;\n      }\n      if (leadZero) {\n        this._maskService.leadZero = leadZero.currentValue;\n      }\n      if (triggerOnMaskChange) {\n        this._maskService.triggerOnMaskChange = triggerOnMaskChange.currentValue;\n      }\n      if (inputTransformFn) {\n        this._maskService.inputTransformFn = inputTransformFn.currentValue;\n      }\n      if (outputTransformFn) {\n        this._maskService.outputTransformFn = outputTransformFn.currentValue;\n      }\n      if (keepCharacterPositions) {\n        this._maskService.keepCharacterPositions = keepCharacterPositions.currentValue;\n      }\n      this._applyMask();\n    }\n    validate({\n      value\n    }) {\n      const processedValue = typeof value === 'number' ? String(value) : value;\n      const maskValue = this._maskValue();\n      if (!this._maskService.validation || !maskValue) {\n        return null;\n      }\n      if (this._maskService.ipError) {\n        return this._createValidationError(processedValue);\n      }\n      if (this._maskService.cpfCnpjError) {\n        return this._createValidationError(processedValue);\n      }\n      if (maskValue.startsWith(MaskExpression.SEPARATOR)) {\n        return null;\n      }\n      if (withoutValidation.includes(maskValue)) {\n        return null;\n      }\n      if (this._maskService.clearIfNotMatch) {\n        return null;\n      }\n      if (timeMasks.includes(maskValue)) {\n        return this._validateTime(processedValue);\n      }\n      if (maskValue === MaskExpression.EMAIL_MASK) {\n        const emailPattern = /^[^@]+@[^@]+\\.[^@]+$/;\n        if (!emailPattern.test(processedValue) && processedValue) {\n          return this._createValidationError(processedValue);\n        } else {\n          return null;\n        }\n      }\n      if (processedValue && processedValue.length >= 1) {\n        let counterOfOpt = 0;\n        if (maskValue.includes(MaskExpression.CURLY_BRACKETS_LEFT) && maskValue.includes(MaskExpression.CURLY_BRACKETS_RIGHT)) {\n          const lengthInsideCurlyBrackets = maskValue.slice(maskValue.indexOf(MaskExpression.CURLY_BRACKETS_LEFT) + 1, maskValue.indexOf(MaskExpression.CURLY_BRACKETS_RIGHT));\n          return lengthInsideCurlyBrackets === String(processedValue.length) ? null : this._createValidationError(processedValue);\n        }\n        if (maskValue.startsWith(MaskExpression.PERCENT)) {\n          return null;\n        }\n        for (const key in this._maskService.patterns) {\n          if (this._maskService.patterns[key]?.optional) {\n            if (maskValue.indexOf(key) !== maskValue.lastIndexOf(key)) {\n              const opt = maskValue.split(MaskExpression.EMPTY_STRING).filter(i => i === key).join(MaskExpression.EMPTY_STRING);\n              counterOfOpt += opt.length;\n            } else if (maskValue.indexOf(key) !== -1) {\n              counterOfOpt++;\n            }\n            if (maskValue.indexOf(key) !== -1 && processedValue.length >= maskValue.indexOf(key)) {\n              return null;\n            }\n            if (counterOfOpt === maskValue.length) {\n              return null;\n            }\n          }\n        }\n        if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) > 1 && processedValue.length < maskValue.indexOf(MaskExpression.SYMBOL_STAR) || maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) > 1 && processedValue.length < maskValue.indexOf(MaskExpression.SYMBOL_QUESTION)) {\n          return this._createValidationError(processedValue);\n        }\n        if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) === -1 || maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) === -1) {\n          const array = maskValue.split('*');\n          const length = this._maskService.dropSpecialCharacters ? maskValue.length - this._maskService.checkDropSpecialCharAmount(maskValue) - counterOfOpt : this.prefix() ? maskValue.length + this.prefix().length - counterOfOpt : maskValue.length - counterOfOpt;\n          if (array.length === 1) {\n            if (processedValue.length < length) {\n              return this._createValidationError(processedValue);\n            }\n          }\n          if (array.length > 1) {\n            const lastIndexArray = array[array.length - 1];\n            if (lastIndexArray && this._maskService.specialCharacters.includes(lastIndexArray[0]) && String(processedValue).includes(lastIndexArray[0] ?? '') && !this.dropSpecialCharacters()) {\n              const special = value.split(lastIndexArray[0]);\n              return special[special.length - 1].length === lastIndexArray.length - 1 ? null : this._createValidationError(processedValue);\n            } else if ((lastIndexArray && !this._maskService.specialCharacters.includes(lastIndexArray[0]) || !lastIndexArray || this._maskService.dropSpecialCharacters) && processedValue.length >= length - 1) {\n              return null;\n            } else {\n              return this._createValidationError(processedValue);\n            }\n          }\n        }\n        if (maskValue.indexOf(MaskExpression.SYMBOL_STAR) === 1 || maskValue.indexOf(MaskExpression.SYMBOL_QUESTION) === 1) {\n          return null;\n        }\n      }\n      if (value) {\n        this.maskFilled.emit();\n        return null;\n      }\n      return null;\n    }\n    onPaste() {\n      this._justPasted.set(true);\n    }\n    onFocus() {\n      this._isFocused.set(true);\n    }\n    onModelChange(value) {\n      // on form reset we need to update the actualValue\n      if ((value === MaskExpression.EMPTY_STRING || value === null || typeof value === 'undefined') && this._maskService.actualValue) {\n        this._maskService.actualValue = this._maskService.getActualValue(MaskExpression.EMPTY_STRING);\n      }\n    }\n    onInput(e) {\n      this._maskService.isInitialized = true;\n      // If IME is composing text, we wait for the composed text.\n      if (this._isComposing()) {\n        return;\n      }\n      const el = e.target;\n      const transformedValue = this._maskService.inputTransformFn ? this._maskService.inputTransformFn(el.value) : el.value;\n      if (el.type !== 'number') {\n        if (typeof transformedValue === 'string' || typeof transformedValue === 'number') {\n          el.value = transformedValue.toString();\n          this._inputValue.set(el.value);\n          this._setMask();\n          if (!this._maskValue()) {\n            this.onChange(el.value);\n            return;\n          }\n          let position = el.selectionStart === 1 ? el.selectionStart + this._maskService.prefix.length : el.selectionStart;\n          if (this.showMaskTyped() && this.keepCharacterPositions() && this._maskService.placeHolderCharacter.length === 1) {\n            const suffix = this.suffix();\n            const prefix = this.prefix();\n            const inputSymbol = el.value.slice(position - 1, position);\n            const prefixLength = prefix.length;\n            const checkSymbols = this._maskService._checkSymbolMask(inputSymbol, this._maskService.maskExpression[position - 1 - prefixLength] ?? MaskExpression.EMPTY_STRING);\n            const checkSpecialCharacter = this._maskService._checkSymbolMask(inputSymbol, this._maskService.maskExpression[position + 1 - prefixLength] ?? MaskExpression.EMPTY_STRING);\n            const selectRangeBackspace = this._maskService.selStart === this._maskService.selEnd;\n            const selStart = Number(this._maskService.selStart) - prefixLength;\n            const selEnd = Number(this._maskService.selEnd) - prefixLength;\n            const backspaceOrDelete = this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE;\n            if (backspaceOrDelete) {\n              if (!selectRangeBackspace) {\n                if (this._maskService.selStart === prefixLength) {\n                  this._maskService.actualValue = `${prefix}${this._maskService.maskIsShown.slice(0, selEnd)}${this._inputValue().split(prefix).join('')}`;\n                } else if (this._maskService.selStart === this._maskService.maskIsShown.length + prefixLength) {\n                  this._maskService.actualValue = `${this._inputValue()}${this._maskService.maskIsShown.slice(selStart, selEnd)}`;\n                } else {\n                  this._maskService.actualValue = `${prefix}${this._inputValue().split(prefix).join('').slice(0, selStart)}${this._maskService.maskIsShown.slice(selStart, selEnd)}${this._maskService.actualValue.slice(selEnd + prefixLength, this._maskService.maskIsShown.length + prefixLength)}${suffix}`;\n                }\n              } else if (!this._maskService.specialCharacters.includes(this._maskService.maskExpression.slice(position - prefixLength, position + 1 - prefixLength)) && selectRangeBackspace) {\n                if (selStart === 1 && prefix) {\n                  this._maskService.actualValue = `${prefix}${this._maskService.placeHolderCharacter}${el.value.split(prefix).join('').split(suffix).join('')}${suffix}`;\n                  position = position - 1;\n                } else {\n                  const part1 = el.value.substring(0, position);\n                  const part2 = el.value.substring(position);\n                  this._maskService.actualValue = `${part1}${this._maskService.placeHolderCharacter}${part2}`;\n                }\n              }\n              position = this._code() === MaskExpression.DELETE ? position + 1 : position;\n            }\n            if (!backspaceOrDelete) {\n              if (!checkSymbols && !checkSpecialCharacter && selectRangeBackspace) {\n                position = Number(el.selectionStart) - 1;\n              } else if (this._maskService.specialCharacters.includes(el.value.slice(position, position + 1)) && checkSpecialCharacter && !this._maskService.specialCharacters.includes(el.value.slice(position + 1, position + 2))) {\n                this._maskService.actualValue = `${el.value.slice(0, position - 1)}${el.value.slice(position, position + 1)}${inputSymbol}${el.value.slice(position + 2)}`;\n                position = position + 1;\n              } else if (checkSymbols) {\n                if (el.value.length === 1 && position === 1) {\n                  this._maskService.actualValue = `${prefix}${inputSymbol}${this._maskService.maskIsShown.slice(1, this._maskService.maskIsShown.length)}${suffix}`;\n                } else {\n                  this._maskService.actualValue = `${el.value.slice(0, position - 1)}${inputSymbol}${el.value.slice(position + 1).split(suffix).join('')}${suffix}`;\n                }\n              } else if (prefix && el.value.length === 1 && position - prefixLength === 1 && this._maskService._checkSymbolMask(el.value, this._maskService.maskExpression[position - 1 - prefixLength] ?? MaskExpression.EMPTY_STRING)) {\n                this._maskService.actualValue = `${prefix}${el.value}${this._maskService.maskIsShown.slice(1, this._maskService.maskIsShown.length)}${suffix}`;\n              }\n            }\n          }\n          let caretShift = 0;\n          let backspaceShift = false;\n          if (this._code() === MaskExpression.DELETE && MaskExpression.SEPARATOR) {\n            this._maskService.deletedSpecialCharacter = true;\n          }\n          if (this._inputValue().length >= this._maskService.maskExpression.length - 1 && this._code() !== MaskExpression.BACKSPACE && this._maskService.maskExpression === MaskExpression.DAYS_MONTHS_YEARS && position < 10) {\n            const inputSymbol = this._inputValue().slice(position - 1, position);\n            el.value = this._inputValue().slice(0, position - 1) + inputSymbol + this._inputValue().slice(position + 1);\n          }\n          if (this._maskService.maskExpression === MaskExpression.DAYS_MONTHS_YEARS && this.leadZeroDateTime()) {\n            if (position < 3 && Number(el.value) > 31 && Number(el.value) < 40 || position === 5 && Number(el.value.slice(3, 5)) > 12) {\n              position = position + 2;\n            }\n          }\n          if (this._maskService.maskExpression === MaskExpression.HOURS_MINUTES_SECONDS && this.apm()) {\n            if (this._justPasted() && el.value.slice(0, 2) === MaskExpression.DOUBLE_ZERO) {\n              el.value = el.value.slice(1, 2) + el.value.slice(2, el.value.length);\n            }\n            el.value = el.value === MaskExpression.DOUBLE_ZERO ? MaskExpression.NUMBER_ZERO : el.value;\n          }\n          this._maskService.applyValueChanges(position, this._justPasted(), this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE, (shift, _backspaceShift) => {\n            this._justPasted.set(false);\n            caretShift = shift;\n            backspaceShift = _backspaceShift;\n          });\n          // only set the selection if the element is active\n          if (this._getActiveElement() !== el) {\n            return;\n          }\n          if (this._maskService.plusOnePosition) {\n            position = position + 1;\n            this._maskService.plusOnePosition = false;\n          }\n          // update position after applyValueChanges to prevent cursor on wrong position when it has an array of maskExpression\n          if (this._maskExpressionArray().length) {\n            if (this._code() === MaskExpression.BACKSPACE) {\n              const specialChartMinusOne = this.specialCharacters().includes(this._maskService.actualValue.slice(position - 1, position));\n              const allowFewMaskChangeMask = this._maskService.removeMask(this._inputValue())?.length === this._maskService.removeMask(this._maskService.maskExpression)?.length;\n              const specialChartPlusOne = this.specialCharacters().includes(this._maskService.actualValue.slice(position, position + 1));\n              if (allowFewMaskChangeMask && !specialChartPlusOne) {\n                position = el.selectionStart + 1;\n              } else {\n                position = specialChartMinusOne ? position - 1 : position;\n              }\n            } else {\n              position = el.selectionStart === 1 ? el.selectionStart + this._maskService.prefix.length : el.selectionStart;\n            }\n          }\n          this._position.set(this._position() === 1 && this._inputValue().length === 1 ? null : this._position());\n          let positionToApply = this._position() ? this._inputValue().length + position + caretShift : position + (this._code() === MaskExpression.BACKSPACE && !backspaceShift ? 0 : caretShift);\n          if (positionToApply > this._getActualInputLength()) {\n            positionToApply = el.value === this._maskService.decimalMarker && el.value.length === 1 ? this._getActualInputLength() + 1 : this._getActualInputLength();\n          }\n          if (positionToApply < 0) {\n            positionToApply = 0;\n          }\n          el.setSelectionRange(positionToApply, positionToApply);\n          this._position.set(null);\n        } else {\n          // eslint-disable-next-line no-console\n          console.warn('Ngx-mask writeValue work with string | number, your current value:', typeof transformedValue);\n        }\n      } else {\n        if (!this._maskValue()) {\n          this.onChange(el.value);\n          return;\n        }\n        this._maskService.applyValueChanges(el.value.length, this._justPasted(), this._code() === MaskExpression.BACKSPACE || this._code() === MaskExpression.DELETE);\n      }\n    }\n    // IME starts\n    onCompositionStart() {\n      this._isComposing.set(true);\n    }\n    // IME completes\n    onCompositionEnd(e) {\n      this._isComposing.set(false);\n      this._justPasted.set(true);\n      this.onInput(e);\n    }\n    onBlur(e) {\n      if (this._maskValue()) {\n        const el = e.target;\n        if (this._maskService.leadZero && el.value.length > 0 && typeof this._maskService.decimalMarker === 'string') {\n          const maskExpression = this._maskService.maskExpression;\n          const decimalMarker = this._maskService.decimalMarker;\n          const suffix = this._maskService.suffix;\n          const precision = Number(this._maskService.maskExpression.slice(maskExpression.length - 1, maskExpression.length));\n          if (precision > 0) {\n            el.value = suffix ? el.value.split(suffix).join('') : el.value;\n            const decimalPart = el.value.split(decimalMarker)[1];\n            el.value = el.value.includes(decimalMarker) ? el.value + MaskExpression.NUMBER_ZERO.repeat(precision - decimalPart.length) + suffix : el.value + decimalMarker + MaskExpression.NUMBER_ZERO.repeat(precision) + suffix;\n            this._maskService.actualValue = el.value;\n          }\n        }\n        this._maskService.clearIfNotMatchFn();\n      }\n      this._isFocused.set(false);\n      this.onTouch();\n    }\n    onClick(e) {\n      if (!this._maskValue()) {\n        return;\n      }\n      const el = e.target;\n      const posStart = 0;\n      const posEnd = 0;\n      if (el !== null && el.selectionStart !== null && el.selectionStart === el.selectionEnd && el.selectionStart > this._maskService.prefix.length && e.keyCode !== 38) {\n        if (this._maskService.showMaskTyped && !this.keepCharacterPositions()) {\n          // We are showing the mask in the input\n          this._maskService.maskIsShown = this._maskService.showMaskInInput();\n          if (el.setSelectionRange && this._maskService.prefix + this._maskService.maskIsShown === el.value) {\n            // the input ONLY contains the mask, so position the cursor at the start\n            el.focus();\n            el.setSelectionRange(posStart, posEnd);\n          } else {\n            // the input contains some characters already\n            if (el.selectionStart > this._maskService.actualValue.length) {\n              // if the user clicked beyond our value's length, position the cursor at the end of our value\n              el.setSelectionRange(this._maskService.actualValue.length, this._maskService.actualValue.length);\n            }\n          }\n        }\n      }\n      const nextValue = el && (el.value === this._maskService.prefix ? this._maskService.prefix + this._maskService.maskIsShown : el.value);\n      /** Fix of cursor position jumping to end in most browsers no matter where cursor is inserted onFocus */\n      if (el && el.value !== nextValue) {\n        el.value = nextValue;\n      }\n      /** fix of cursor position with prefix when mouse click occur */\n      if (el && el.type !== 'number' && (el.selectionStart || el.selectionEnd) <= this._maskService.prefix.length) {\n        const specialCharactersAtTheStart = this._maskService.maskExpression.match(new RegExp(`^[${this._maskService.specialCharacters.map(c => `\\\\${c}`).join('')}]+`))?.[0].length || 0;\n        el.selectionStart = this._maskService.prefix.length + specialCharactersAtTheStart;\n        return;\n      }\n      /** select only inserted text */\n      if (el && el.selectionEnd > this._getActualInputLength()) {\n        el.selectionEnd = this._getActualInputLength();\n      }\n    }\n    onKeyDown(e) {\n      if (!this._maskValue()) {\n        return;\n      }\n      if (this._isComposing()) {\n        // User finalize their choice from IME composition, so trigger onInput() for the composed text.\n        if (e.key === 'Enter') {\n          this.onCompositionEnd(e);\n        }\n        return;\n      }\n      this._code.set(e.code ? e.code : e.key);\n      const el = e.target;\n      this._inputValue.set(el.value);\n      this._setMask();\n      const isTextarea = el.tagName.toLowerCase() === 'textarea';\n      if (el.type !== 'number') {\n        if (e.key === MaskExpression.ARROW_UP && !isTextarea) {\n          e.preventDefault();\n        }\n        if (e.key === MaskExpression.ARROW_LEFT || e.key === MaskExpression.BACKSPACE || e.key === MaskExpression.DELETE) {\n          if (e.key === MaskExpression.BACKSPACE && el.value.length === 0) {\n            el.selectionStart = el.selectionEnd;\n          }\n          if (e.key === MaskExpression.BACKSPACE && el.selectionStart !== 0) {\n            const prefixLength = this.prefix().length;\n            // If specialChars is false, (shouldn't ever happen) then set to the defaults\n            const specialCharacters = this.specialCharacters().length ? this.specialCharacters() : this._config.specialCharacters;\n            if (prefixLength > 1 && el.selectionStart <= prefixLength) {\n              el.setSelectionRange(prefixLength, el.selectionEnd);\n            } else {\n              if (this._inputValue().length !== el.selectionStart && el.selectionStart !== 1) {\n                while (specialCharacters.includes((this._inputValue()[el.selectionStart - 1] ?? MaskExpression.EMPTY_STRING).toString()) && (prefixLength >= 1 && el.selectionStart > prefixLength || prefixLength === 0)) {\n                  el.setSelectionRange(el.selectionStart - 1, el.selectionEnd);\n                }\n              }\n            }\n          }\n          this.checkSelectionOnDeletion(el);\n          if (this._maskService.prefix.length && el.selectionStart <= this._maskService.prefix.length && el.selectionEnd <= this._maskService.prefix.length) {\n            e.preventDefault();\n          }\n          const cursorStart = el.selectionStart;\n          if (e.key === MaskExpression.BACKSPACE && !el.readOnly && cursorStart === 0 && el.selectionEnd === el.value.length && el.value.length !== 0) {\n            this._position.set(this._maskService.prefix ? this._maskService.prefix.length : 0);\n            this._maskService.applyMask(this._maskService.prefix, this._maskService.maskExpression, this._position());\n          }\n        }\n        if (!!this.suffix() && this.suffix().length > 1 && this._inputValue().length - this.suffix().length < el.selectionStart) {\n          el.setSelectionRange(this._inputValue().length - this.suffix().length, this._inputValue().length);\n        } else if (e.code === 'KeyA' && e.ctrlKey || e.code === 'KeyA' && e.metaKey // Cmd + A (Mac)\n        ) {\n          el.setSelectionRange(0, this._getActualInputLength());\n          e.preventDefault();\n        }\n        this._maskService.selStart = el.selectionStart;\n        this._maskService.selEnd = el.selectionEnd;\n      }\n    }\n    /** It writes the value in the input */\n    writeValue(controlValue) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        let value = controlValue;\n        const inputTransformFn = _this._maskService.inputTransformFn;\n        if (typeof value === 'object' && value !== null && 'value' in value) {\n          if ('disable' in value) {\n            _this.setDisabledState(Boolean(value.disable));\n          }\n          value = value.value;\n        }\n        if (value !== null) {\n          value = inputTransformFn ? inputTransformFn(value) : value;\n        }\n        if (typeof value === 'string' || typeof value === 'number' || value === null || typeof value === 'undefined') {\n          if (value === null || typeof value === 'undefined' || value === '') {\n            _this._maskService.currentValue = '';\n            _this._maskService.previousValue = '';\n          }\n          let inputValue = value;\n          if (typeof inputValue === 'number' || _this._maskValue().startsWith(MaskExpression.SEPARATOR)) {\n            inputValue = String(inputValue);\n            const localeDecimalMarker = _this._maskService.currentLocaleDecimalMarker();\n            if (!Array.isArray(_this._maskService.decimalMarker)) {\n              inputValue = _this._maskService.decimalMarker !== localeDecimalMarker ? inputValue.replace(localeDecimalMarker, _this._maskService.decimalMarker) : inputValue;\n            }\n            if (_this._maskService.leadZero && inputValue && _this.mask() && _this.dropSpecialCharacters() !== false) {\n              inputValue = _this._maskService._checkPrecision(_this._maskService.maskExpression, inputValue);\n            }\n            if (_this._maskService.decimalMarker === MaskExpression.COMMA || Array.isArray(_this._maskService.decimalMarker) && _this._maskService.thousandSeparator === MaskExpression.DOT) {\n              inputValue = inputValue.toString().replace(MaskExpression.DOT, MaskExpression.COMMA);\n            }\n            if (_this.mask()?.startsWith(MaskExpression.SEPARATOR) && _this.leadZero()) {\n              requestAnimationFrame(() => {\n                _this._maskService.applyMask(inputValue?.toString() ?? '', _this._maskService.maskExpression);\n              });\n            }\n            _this._maskService.isNumberValue = true;\n          }\n          if (typeof inputValue !== 'string' || value === null || typeof value === 'undefined') {\n            inputValue = '';\n          }\n          _this._inputValue.set(inputValue);\n          _this._setMask();\n          if (inputValue && _this._maskService.maskExpression || _this._maskService.maskExpression && (_this._maskService.prefix || _this._maskService.showMaskTyped)) {\n            // Let the service we know we are writing value so that triggering onChange function won't happen during applyMask\n            _this._maskService.writingValue = true;\n            _this._maskService.formElementProperty = ['value', _this._maskService.applyMask(inputValue, _this._maskService.maskExpression)];\n            // Let the service know we've finished writing value\n            _this._maskService.writingValue = false;\n            _this._maskService.isInitialized = true;\n          } else {\n            _this._maskService.formElementProperty = ['value', inputValue];\n            _this._maskService.isInitialized = true;\n          }\n          _this._inputValue.set(inputValue);\n        } else {\n          // eslint-disable-next-line no-console\n          console.warn('Ngx-mask writeValue work with string | number, your current value:', typeof value);\n        }\n      })();\n    }\n    registerOnChange(fn) {\n      this._maskService.onChange = this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouch = fn;\n    }\n    _getActiveElement(document = this.document) {\n      const shadowRootEl = document?.activeElement?.shadowRoot;\n      if (!shadowRootEl?.activeElement) {\n        return document.activeElement;\n      } else {\n        return this._getActiveElement(shadowRootEl);\n      }\n    }\n    checkSelectionOnDeletion(el) {\n      const prefixLength = this.prefix().length;\n      const suffixLength = this.suffix().length;\n      const inputValueLength = this._inputValue().length;\n      el.selectionStart = Math.min(Math.max(prefixLength, el.selectionStart), inputValueLength - suffixLength);\n      el.selectionEnd = Math.min(Math.max(prefixLength, el.selectionEnd), inputValueLength - suffixLength);\n    }\n    /** It disables the input element */\n    setDisabledState(isDisabled) {\n      this._maskService.formElementProperty = ['disabled', isDisabled];\n    }\n    _applyMask() {\n      this._maskService.maskExpression = this._maskService._repeatPatternSymbols(this._maskValue() || '');\n      this._maskService.formElementProperty = ['value', this._maskService.applyMask(this._inputValue(), this._maskService.maskExpression)];\n    }\n    _validateTime(value) {\n      const rowMaskLen = this._maskValue().split(MaskExpression.EMPTY_STRING).filter(s => s !== ':').length;\n      if (!value) {\n        return null; // Don't validate empty values to allow for optional form control\n      }\n      if (+(value[value.length - 1] ?? -1) === 0 && value.length < rowMaskLen || value.length <= rowMaskLen - 2) {\n        return this._createValidationError(value);\n      }\n      return null;\n    }\n    _getActualInputLength() {\n      return this._maskService.actualValue.length || this._maskService.actualValue.length + this._maskService.prefix.length;\n    }\n    _createValidationError(actualValue) {\n      return {\n        mask: {\n          requiredMask: this._maskValue(),\n          actualValue\n        }\n      };\n    }\n    _setMask() {\n      this._maskExpressionArray().some(mask => {\n        const specialChart = mask.split(MaskExpression.EMPTY_STRING).some(char => this._maskService.specialCharacters.includes(char));\n        if (specialChart && this._inputValue() && this._areAllCharactersInEachStringSame(this._maskExpressionArray()) || mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)) {\n          const test = this._maskService.removeMask(this._inputValue())?.length <= this._maskService.removeMask(mask)?.length;\n          if (test) {\n            const maskValue = mask.includes(MaskExpression.CURLY_BRACKETS_LEFT) ? this._maskService._repeatPatternSymbols(mask) : mask;\n            this._maskValue.set(maskValue);\n            this._maskService.maskExpression = maskValue;\n            return test;\n          } else {\n            const expression = this._maskExpressionArray()[this._maskExpressionArray().length - 1] ?? MaskExpression.EMPTY_STRING;\n            const maskValue = expression.includes(MaskExpression.CURLY_BRACKETS_LEFT) ? this._maskService._repeatPatternSymbols(expression) : expression;\n            this._maskValue.set(maskValue);\n            this._maskService.maskExpression = maskValue;\n          }\n        } else {\n          const cleanMask = this._maskService.removeMask(mask);\n          const check = this._maskService.removeMask(this._inputValue())?.split(MaskExpression.EMPTY_STRING).every((character, index) => {\n            const indexMask = cleanMask.charAt(index);\n            return this._maskService._checkSymbolMask(character, indexMask);\n          });\n          if (check || this._justPasted()) {\n            this._maskValue.set(mask);\n            this._maskService.maskExpression = mask;\n            return check;\n          }\n        }\n      });\n    }\n    _areAllCharactersInEachStringSame(array) {\n      const specialCharacters = this._maskService.specialCharacters;\n      function removeSpecialCharacters(str) {\n        const regex = new RegExp(`[${specialCharacters.map(ch => `\\\\${ch}`).join('')}]`, 'g');\n        return str.replace(regex, '');\n      }\n      const processedArr = array.map(removeSpecialCharacters);\n      return processedArr.every(str => {\n        const uniqueCharacters = new Set(str);\n        return uniqueCharacters.size === 1;\n      });\n    }\n    static ɵfac = function NgxMaskDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxMaskDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgxMaskDirective,\n      selectors: [[\"input\", \"mask\", \"\"], [\"textarea\", \"mask\", \"\"]],\n      hostBindings: function NgxMaskDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"paste\", function NgxMaskDirective_paste_HostBindingHandler() {\n            return ctx.onPaste();\n          })(\"focus\", function NgxMaskDirective_focus_HostBindingHandler($event) {\n            return ctx.onFocus($event);\n          })(\"ngModelChange\", function NgxMaskDirective_ngModelChange_HostBindingHandler($event) {\n            return ctx.onModelChange($event);\n          })(\"input\", function NgxMaskDirective_input_HostBindingHandler($event) {\n            return ctx.onInput($event);\n          })(\"compositionstart\", function NgxMaskDirective_compositionstart_HostBindingHandler($event) {\n            return ctx.onCompositionStart($event);\n          })(\"compositionend\", function NgxMaskDirective_compositionend_HostBindingHandler($event) {\n            return ctx.onCompositionEnd($event);\n          })(\"blur\", function NgxMaskDirective_blur_HostBindingHandler($event) {\n            return ctx.onBlur($event);\n          })(\"click\", function NgxMaskDirective_click_HostBindingHandler($event) {\n            return ctx.onClick($event);\n          })(\"keydown\", function NgxMaskDirective_keydown_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          });\n        }\n      },\n      inputs: {\n        mask: [1, \"mask\"],\n        specialCharacters: [1, \"specialCharacters\"],\n        patterns: [1, \"patterns\"],\n        prefix: [1, \"prefix\"],\n        suffix: [1, \"suffix\"],\n        thousandSeparator: [1, \"thousandSeparator\"],\n        decimalMarker: [1, \"decimalMarker\"],\n        dropSpecialCharacters: [1, \"dropSpecialCharacters\"],\n        hiddenInput: [1, \"hiddenInput\"],\n        showMaskTyped: [1, \"showMaskTyped\"],\n        placeHolderCharacter: [1, \"placeHolderCharacter\"],\n        shownMaskExpression: [1, \"shownMaskExpression\"],\n        clearIfNotMatch: [1, \"clearIfNotMatch\"],\n        validation: [1, \"validation\"],\n        separatorLimit: [1, \"separatorLimit\"],\n        allowNegativeNumbers: [1, \"allowNegativeNumbers\"],\n        leadZeroDateTime: [1, \"leadZeroDateTime\"],\n        leadZero: [1, \"leadZero\"],\n        triggerOnMaskChange: [1, \"triggerOnMaskChange\"],\n        apm: [1, \"apm\"],\n        inputTransformFn: [1, \"inputTransformFn\"],\n        outputTransformFn: [1, \"outputTransformFn\"],\n        keepCharacterPositions: [1, \"keepCharacterPositions\"],\n        instantPrefix: [1, \"instantPrefix\"]\n      },\n      outputs: {\n        maskFilled: \"maskFilled\"\n      },\n      exportAs: [\"mask\", \"ngxMask\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: NgxMaskDirective,\n        multi: true\n      }, {\n        provide: NG_VALIDATORS,\n        useExisting: NgxMaskDirective,\n        multi: true\n      }, NgxMaskService]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgxMaskDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMaskPipe = /*#__PURE__*/(() => {\n  class NgxMaskPipe {\n    defaultOptions = inject(NGX_MASK_CONFIG);\n    _maskService = inject(NgxMaskService);\n    _maskExpressionArray = [];\n    mask = '';\n    transform(value, mask, {\n      patterns,\n      ...config\n    } = {}) {\n      let processedValue = value;\n      const currentConfig = {\n        maskExpression: mask,\n        ...this.defaultOptions,\n        ...config,\n        patterns: {\n          ...this._maskService.patterns,\n          ...patterns\n        }\n      };\n      Object.entries(currentConfig).forEach(([key, val]) => {\n        this._maskService[key] = val;\n      });\n      if (mask.includes('||')) {\n        const maskParts = mask.split('||');\n        if (maskParts.length > 1) {\n          this._maskExpressionArray = maskParts.sort((a, b) => a.length - b.length);\n          this._setMask(`${processedValue}`);\n          return this._maskService.applyMask(`${processedValue}`, this.mask);\n        } else {\n          this._maskExpressionArray = [];\n          return this._maskService.applyMask(`${processedValue}`, this.mask);\n        }\n      }\n      if (mask.includes(MaskExpression.CURLY_BRACKETS_LEFT)) {\n        return this._maskService.applyMask(`${processedValue}`, this._maskService._repeatPatternSymbols(mask));\n      }\n      if (mask.startsWith(MaskExpression.SEPARATOR)) {\n        if (config.decimalMarker) {\n          this._maskService.decimalMarker = config.decimalMarker;\n        }\n        if (config.thousandSeparator) {\n          this._maskService.thousandSeparator = config.thousandSeparator;\n        }\n        if (config.leadZero) {\n          this._maskService.leadZero = config.leadZero;\n        }\n        processedValue = String(processedValue);\n        const localeDecimalMarker = this._maskService.currentLocaleDecimalMarker();\n        if (!Array.isArray(this._maskService.decimalMarker)) {\n          processedValue = this._maskService.decimalMarker !== localeDecimalMarker ? processedValue.replace(localeDecimalMarker, this._maskService.decimalMarker) : processedValue;\n        }\n        if (this._maskService.leadZero && processedValue && this._maskService.dropSpecialCharacters !== false) {\n          processedValue = this._maskService._checkPrecision(mask, processedValue);\n        }\n        if (this._maskService.decimalMarker === MaskExpression.COMMA) {\n          processedValue = processedValue.replace(MaskExpression.DOT, MaskExpression.COMMA);\n        }\n        this._maskService.isNumberValue = true;\n      }\n      if (processedValue === null || typeof processedValue === 'undefined') {\n        return this._maskService.applyMask('', mask);\n      }\n      return this._maskService.applyMask(`${processedValue}`, mask);\n    }\n    _setMask(value) {\n      if (this._maskExpressionArray.length > 0) {\n        this._maskExpressionArray.some(mask => {\n          const test = this._maskService.removeMask(value)?.length <= this._maskService.removeMask(mask)?.length;\n          if (value && test) {\n            this.mask = mask;\n            return test;\n          } else {\n            this.mask = this._maskExpressionArray[this._maskExpressionArray.length - 1] ?? MaskExpression.EMPTY_STRING;\n          }\n        });\n      }\n    }\n    static ɵfac = function NgxMaskPipe_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxMaskPipe)();\n    };\n    static ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n      name: \"mask\",\n      type: NgxMaskPipe,\n      pure: true,\n      standalone: true\n    });\n  }\n  return NgxMaskPipe;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_CONFIG, NEW_CONFIG, NGX_MASK_CONFIG, NgxMaskDirective, NgxMaskPipe, NgxMaskService, initialConfig, provideEnvironmentNgxMask, provideNgxMask, timeMasks, withoutValidation };\n//# sourceMappingURL=ngx-mask.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}